<!DOCTYPE html><html lang="en"><head><title>[UKR] Сегментація міст з використанням дорожньої сітки на основі відкритих супутникових даних</title><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="yandex-verification" content="39324391851d1a5d"/><meta name="google-site-verification" content="pnATuZP_aTcMjckmXnh2j6oO8Mk9YXUA7GfE7UO4QXk"/><link rel="stylesheet" href="/assets/css/site.css"/><meta property="og:type" content="article"/><meta property="og:site_name" content="@rapkin | Software developer"/><meta itemProp="og:title" content="[UKR] Сегментація міст з використанням дорожньої сітки на основі відкритих супутникових даних"/><meta itemProp="name" content="[UKR] Сегментація міст з використанням дорожньої сітки на основі відкритих супутникових даних"/><meta name="author" content="Mikola Parfenyuck"/><meta property="article:author" content="Mikola Parfenyuck"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@i_rapkin"/><meta name="twitter:title" content="[UKR] Сегментація міст з використанням дорожньої сітки на основі відкритих супутникових даних"/><meta name="description" content="Магістерська робота присвячена розробці алгоритму для автоматичної розмітки та класифікації зон міст з використанням Python, Shapely та OpenStreetMap"/><meta itemProp="description" content="Магістерська робота присвячена розробці алгоритму для автоматичної розмітки та класифікації зон міст з використанням Python, Shapely та OpenStreetMap"/><meta property="og:description" content="Магістерська робота присвячена розробці алгоритму для автоматичної розмітки та класифікації зон міст з використанням Python, Shapely та OpenStreetMap"/><meta name="twitter:description" content="Магістерська робота присвячена розробці алгоритму для автоматичної розмітки та класифікації зон міст з використанням Python, Shapely та OpenStreetMap"/><meta itemProp="image" content="https://rapkin.com.ua/assets/optimized-img/segmentation-title.png"/><meta property="og:image" content="https://rapkin.com.ua/assets/optimized-img/segmentation-title.png"/><meta name="twitter:image" content="https://rapkin.com.ua/assets/optimized-img/segmentation-title.png"/><meta name="google" content="nositelinkssearchbox"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","author":"Mikola Parfenyuck","headline":"[UKR] Сегментація міст з використанням дорожньої сітки на основі відкритих супутникових даних","datePublished":"2019-12-23T21:42:13.000Z","publisher":{"@type":"Organization","name":"rapkin","url":"https://rapkin.com.ua","logo":{"@type":"ImageObject","url":"https://rapkin.com.ua/assets/optimized-img/bunny.png"}},"image":"https://rapkin.com.ua/assets/optimized-img/segmentation-title.png","name":"[UKR] Сегментація міст з використанням дорожньої сітки на основі відкритих супутникових даних"}</script><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/inconsolata-v18-latin-regular.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-italic.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-700.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-700italic.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-regular.woff2" crossorigin="true"/></head><body><div class="top"><header role="banner"><a class="logo" href="/">@rapkin</a><span class="logo-details">Software developer</span><ul class="menu-wrapper"><li><a class="menu-item" href="/resume/">Resume</a></li><li><a class="menu-item" href="/about/">About</a></li></ul></header><main id="swup"><h2 id="вступ">Вступ</h2>
<p>Інколи розділити якусь територію на набір зон може бути корисно. Для прикладу сегментувати знімки з супутника.
Надалі можна використати ці дані для навчання нейронних мереж, які будуть автоматично класифікувати територію на основі нових знімків, або ж знімків територій, що мають недостатнє охоплення векторними даними.</p>
<p>Актуальність теми зумовлена стрімким розвитком сфери нейронних мереж та машинного навчання. І одним з розділів цієї сфери є саме генерація та підбір інформації на якій проводитиметься навчання штучних нейронних мереж. В даному випадку утворений набір даних можна використати при розв&#39;язанні задачі автоматичної сегментації та класифікації урбанізованих територій. Також карта сегментованих територій надає візуальне представлення функціональних зон міста і може виявитись корисною для органів самоврядування при плануванні міської забудови.</p>
<p>Метою роботи є аналіз та створення алгоритму для ефективного сегментування урбанізованих територій використовуючи відкриті джерела інформації. Потрібно отримати векторну розмітку зон міста (класифікованих за набором правил).
Зони мають бути виділені на основі сітки доріг, залізничних шляхів, водних об&#39;єктів.</p>
<p>Об&#39;єктом дослідження є набір відкритої векторної інформації ресурсу OSM.
Предметом дослідження — сукупність інструментів та методів аналізу геопросторової інформації, алгоритми для проведення геометричних операцій та оптимізації виконання цих операцій.</p>
<p>Наукова новизна полягає в розробці оптимального алгоритму для сегментації урбанізованих територій з використанням відкритих векторних даних.</p>
<h2 id="розділ-1-постановка-та-способи-вирішення-задачі">Розділ 1. Постановка та способи вирішення задачі</h2>
<h3 id="постановка-задачі">Постановка задачі</h3>
<p>Суть задачі полягає в побудові набору полігонів прокласифікованих за заданим набором правил на певні класи. При цьому необхідно досягнути розділення зон міста (полігонів) з використанням сітки доріг.</p>
<p>В даній роботі було використано 6 класів:</p>
<ul>
<li><strong>Забудова</strong> — житлові будинки, об&#39;єкти промисловості та інша забудова</li>
<li><strong>Агро-зона</strong> — сільськогосподарські угіддя</li>
<li><strong>Ліси</strong></li>
<li><strong>Дороги</strong> — автомобільні дороги, асфальтовані покриття (не враховуються грунтові дороги)</li>
<li><strong>Залізничні шляхи</strong></li>
<li><strong>Водні території</strong> — річки, озера, моря і тд.</li>
</ul>
<p>Потрібно реалізувати алгоритм який на вході прийматиме ідентифікатиор міста (в даному випадку id міста у відкритому джерелі OSM), завантажуватиме необхідну для розграхунків геометрію, формуватиме набір класифікованих полігонів та зберігатиме даний набір в GeoJSON файл.</p>
<h3 id="наявні-способи-вирішення-задачі-сегментації">Наявні способи вирішення задачі сегментації</h3>
<p>Вибраний спосіб сегментування міської території відрізняється від знайдених аналогів маштабом сегментації. Більшість досліджень працюють на основі зображень високої роздільної здатності і проводять сегментацію на рівні конкретних об&#39;єктів (будинків, дерев і тд.). Запропонований у цій роботі метод ставить за ціль провести автоматичну сегментацію на більшому маштабі. Ще одною принциповою відмінністю є те, що для сегментації не використовуються растрові знімки супутника, а лише відкрите джерело інформації OSM.
Спільною рисою є те, що отримані у цьому дослідженні результати можна використати для сегментації растрових супутникових зображень.</p>
<p>Метааналіз існуючих методів сегментації урбанізованих територій на основі растрових супутникових зображень
<a href="https://www.researchgate.net/publication/322291244_Identifying_Generalizable_Image_Segmentation_Parameters_for_Urban_Land_Cover_Mapping_through_Meta-Analysis_and_Regression_Tree_Modeling" target="_blank" rel="noopener" >https://www.researchgate.net/publication/322291244_Identifying_Generalizable_Image_Segmentation_Parameters_for_Urban_Land_Cover_Mapping_through_Meta-Analysis_and_Regression_Tree_Modeling</a></p>
<h3 id="запропонований-алгоритм">Запропонований алгоритм</h3>
<ul>
<li><p>Завантаження геометрії coastline (це необхідно для правильної побудови зон міст які знаходяться біля океану).</p>
</li>
<li><p>Завантаження межі міста з OSM і формування з неї полігону (або мультиполігону в загальному випадку).</p>
</li>
<li><p>Завантаження автомобільних шляхи, залізничних шляхів, водних об&#39;єктів і формування з них відповідної геометрії (навколо ліній будуються буфери, полігони залишаються у вигляді полігонів).</p>
</li>
<li><p>Завантаження іншої геометрії з OSM, яка необхідна для подальшої класифікації (це теж полігони).</p>
</li>
<li><p>Проектування всієї геометрії в прямокутну систему координат аби позбутись спотворень при виконанні геометричних операцій.</p>
</li>
<li><p>Формування мультиполігону вирахуваної об&#39;єднаної зони доріг.</p>
</li>
<li><p>Аналогічно формується мультиполігон водних об&#39;єктів.</p>
</li>
<li><p>Від межі міста віднімаються сформовані мультиполігони доріг (автомобільних та залізничних) і водних об&#39;єктів, що в результаті дасть мультиполігон нерозмічених зон.</p>
</li>
<li><p>Класифікація кожної зони за певним набором правил, наприклад знаходженням суми пересічень з іншими об&#39;єктами на карті (будинками, полями і т.д.).</p>
</li>
<li><p>Проекція назад у полярну систему координат.</p>
</li>
<li><p>Збереження результатів.</p>
</li>
</ul>
<p>На цьому алгоритм можна було б і завершити, але через візуальну засміченість результатів такого &quot;простого&quot; алгоритму, появилась необхідність провести додаткові трансформації геометрії.</p>
<p><div class="lazyload" style="padding-bottom: 63.36559940431869%" data-bg="url(/assets/optimized-img/not-merged.png)" title="Залізнична розв&#39;язка у місті Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/not-merged.png"></a></div></p>
<p>Тому перед відніманням зони доріг від межі міста можна додати пункт:</p>
<ul>
<li>Об&#39;єднання паралельних та близько розміщених доріг.</li>
</ul>
<p>А перед пунктом класифікації додамо ще один пункт:</p>
<ul>
<li>Згладження форми отриманих нерозмічених зон.</li>
</ul>
<p>Варто зазначити, що в деяких місцях порядок не обов&#39;язковий і є можливість асинхронно виконувати якісь завдання (наприклад завантаження інформації, або робота з кожним класом геометрії).</p>
<h3 id="технології-використані-для-вирішення-задачі">Технології використані для вирішення задачі</h3>
<p>Для реалізації алгоритму було використано наступний набір технологій та ресурсів:</p>
<ul>
<li><p><strong>Python (Cython)</strong> — насправді можна реалізувати аналогічний алгоритм і іншою мовою програмування (наприклад використавши JavaScript та Turf.js), та в деяких місцях на Python дає можливість щось оптимізувати без особливих зусиль. Наприклад, використати Cython для компіляції коду написаного на Python в нативне розширення.</p>
</li>
<li><p><strong>Shapely</strong> — бібліотека для Python, яка надає функції для операцій з геометрією.</p>
</li>
<li><p><strong>Geopandas</strong> — потрібен для роботи з датасетами shape-файлів.</p>
</li>
<li><p><strong>OSM (OpenStreetMap)</strong> — відкритий ресурс, де і буде взято всю необхідну геометрію.</p>
</li>
<li><p><strong>Overpass</strong> — API щоб завантажувати, фільтрувати чи трансформувати дані з OSM.</p>
</li>
<li><p><strong>Osm2geojson</strong> — бібліотека для конвертації даних OSM (та Overpass) в геометрію GeoJSON або об&#39;єкти геометрії Shapely.</p>
</li>
<li><p><strong>Land polygons</strong> — датасет берегової лінії <a href="https://osmdata.openstreetmap.de/data/land-polygons.html" target="_blank" rel="noopener" >https://osmdata.openstreetmap.de/data/land-polygons.html</a></p>
</li>
<li><p><strong>QGIS</strong> — графічний інтерфейс для візуалізації та роботи з просторовими даними.</p>
</li>
</ul>
<h2 id="розділ-2-методи-збереження-та-обробки-геопросторових-даних">Розділ 2. Методи збереження та обробки геопросторових даних</h2>
<h3 id="геопросторові-дані-види-геометрії">Геопросторові дані, види геометрії</h3>
<p>Геопросторові дані — дані про просторові об&#39;єкти та їх набори, вони складають основу інформаційного забезпечення геоінформаційних систем. Більшість геоінформаційних систем працюють з наступним набором примітивів:</p>
<ul>
<li>Точка (Point)</li>
<li>Відрізок (Linestring)</li>
<li>Багатокутник (Polygon)</li>
<li>Набір точок (MultiPoint)</li>
<li>Набір відрізків (MultiLinestring)</li>
<li>Набір багатокутників (MultiPolygon)</li>
<li>Колекція типів (GeometryCollection)</li>
</ul>
<p>Просторові дані зазвичай складаються з двох взаємопов&#39;язаних частин: координатних і атрибутивних даних. Встановлення зв&#39;язку між цими частинами називається геокодування.</p>
<p>Координатні дані визначають позиційні характеристики просторового об&#39;єкта. Вони описують його місце розташування у встановленій системі координат.</p>
<p>Атрибутивні дані представляють собою сукупність непозиційних характеристик (атрибутів) просторового об&#39;єкта. Атрибутивні дані визначають смисловий зміст (семантику) об&#39;єкта і можуть містити якісні або кількісні значення.</p>
<h3 id="стандарт-osm">Стандарт OSM</h3>
<p>OpenStreetMap (далі OSM) — це відкритий проект спрямований на збір, збереження та розповсюдження загальнодоступних геопросторових даних. В рамках цього проекту існує стандарт збреження цієї геопросторової інформації. Для зручного збереження такої частозмінюваної інформації використовується XML-файл в якому міститься розмітка об&#39;єктів для всієї Землі. OSM використовує рівнокутну проекцію Меркатора.</p>
<p>Геопросторові дані проекту OpenStreetMap ліцензуються на умовах Open Database License, яка дозволяє їх використання з будь-якою, у т.ч. комерційною метою, за умови зазначення походження даних.</p>
<p>Базові інструменти OSM оперують даними у форматі XML, який описує набір елементів (вузли, відрізки та зв&#39;язки).
Елементи, або базові примітиви включають:</p>
<ul>
<li>Точка (вузол) — позначає окрему геопросторову точку, характеризується щонайменше широтою та довготою.</li>
<li>Лінія — впорядкований за напрямком список від 2 до 2000 точок. Використовується для позначення лінійних структур або площин (якщо лінія замкнута).</li>
<li>Зв&#39;язок — впорядкований список з елементів, тобто точок, ліній, та інших зв&#39;язків. Окремі елементи зв&#39;язків характеризуються первними ролями. Типовим прикладом зв&#39;язку може бути маршрут громадського транспорту, який включає лінії автошляхів та точки зупинок.</li>
<li>Тег — певна інформація, пов&#39;язана з одним із зазначених вище елементів. Складається з двох текстових полів довільного формату, &#39;ключ&#39; та &#39;значення&#39;.</li>
</ul>
<p>Приклад такого XML-файлу:</p>
<pre><code data-lang="xml" class="hljs"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">osm</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"0.6"</span> <span class="hljs-attr">generator</span>=<span class="hljs-string">"CGImap 0.0.2"</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">bounds</span> <span class="hljs-attr">minlat</span>=<span class="hljs-string">"54.0889580"</span> <span class="hljs-attr">minlon</span>=<span class="hljs-string">"12.2487570"</span> <span class="hljs-attr">maxlat</span>=<span class="hljs-string">"54.0913900"</span> <span class="hljs-attr">maxlon</span>=<span class="hljs-string">"12.2524800"</span>/&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"298884269"</span> <span class="hljs-attr">lat</span>=<span class="hljs-string">"54.0901746"</span> <span class="hljs-attr">lon</span>=<span class="hljs-string">"12.2482632"</span> <span class="hljs-attr">user</span>=<span class="hljs-string">"SvenHRO"</span> <span class="hljs-attr">uid</span>=<span class="hljs-string">"46882"</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">changeset</span>=<span class="hljs-string">"676636"</span> <span class="hljs-attr">timestamp</span>=<span class="hljs-string">"2008-09-21T21:37:45Z"</span>/&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"261728686"</span> <span class="hljs-attr">lat</span>=<span class="hljs-string">"54.0906309"</span> <span class="hljs-attr">lon</span>=<span class="hljs-string">"12.2441924"</span> <span class="hljs-attr">user</span>=<span class="hljs-string">"PikoWinter"</span> <span class="hljs-attr">uid</span>=<span class="hljs-string">"36744"</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">changeset</span>=<span class="hljs-string">"323878"</span> <span class="hljs-attr">timestamp</span>=<span class="hljs-string">"2008-05-03T13:39:23Z"</span>/&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"1831881213"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">changeset</span>=<span class="hljs-string">"12370172"</span> <span class="hljs-attr">lat</span>=<span class="hljs-string">"54.0900666"</span> <span class="hljs-attr">lon</span>=<span class="hljs-string">"12.2539381"</span> <span class="hljs-attr">user</span>=<span class="hljs-string">"lafkor"</span> <span class="hljs-attr">uid</span>=<span class="hljs-string">"75625"</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">timestamp</span>=<span class="hljs-string">"2012-07-20T09:43:19Z"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"Neu Broderstorf"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"traffic_sign"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"city_limit"</span>/&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span>
 ...
 <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"298884272"</span> <span class="hljs-attr">lat</span>=<span class="hljs-string">"54.0901447"</span> <span class="hljs-attr">lon</span>=<span class="hljs-string">"12.2516513"</span> <span class="hljs-attr">user</span>=<span class="hljs-string">"SvenHRO"</span> <span class="hljs-attr">uid</span>=<span class="hljs-string">"46882"</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"1"</span> <span class="hljs-attr">changeset</span>=<span class="hljs-string">"676636"</span> <span class="hljs-attr">timestamp</span>=<span class="hljs-string">"2008-09-21T21:37:45Z"</span>/&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">way</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"26659127"</span> <span class="hljs-attr">user</span>=<span class="hljs-string">"Masch"</span> <span class="hljs-attr">uid</span>=<span class="hljs-string">"55988"</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"5"</span> <span class="hljs-attr">changeset</span>=<span class="hljs-string">"4142606"</span> <span class="hljs-attr">timestamp</span>=<span class="hljs-string">"2010-03-16T11:47:08Z"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">nd</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"292403538"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">nd</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"298884289"</span>/&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">nd</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"261728686"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"highway"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"unclassified"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"Pastower Straße"</span>/&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">way</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">relation</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"56688"</span> <span class="hljs-attr">user</span>=<span class="hljs-string">"kmvar"</span> <span class="hljs-attr">uid</span>=<span class="hljs-string">"56190"</span> <span class="hljs-attr">visible</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">version</span>=<span class="hljs-string">"28"</span> <span class="hljs-attr">changeset</span>=<span class="hljs-string">"6947637"</span> <span class="hljs-attr">timestamp</span>=<span class="hljs-string">"2011-01-12T14:23:49Z"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"node"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"294942404"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">""</span>/&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"node"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"364933006"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">""</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"way"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"4579143"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">""</span>/&gt;</span>
  ...
  <span class="hljs-tag">&lt;<span class="hljs-name">member</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"node"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"249673494"</span> <span class="hljs-attr">role</span>=<span class="hljs-string">""</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"Küstenbus Linie 123"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"network"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"VVW"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"operator"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"Regionalverkehr Küste"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"ref"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"123"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"route"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"bus"</span>/&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">tag</span> <span class="hljs-attr">k</span>=<span class="hljs-string">"type"</span> <span class="hljs-attr">v</span>=<span class="hljs-string">"route"</span>/&gt;</span>
 <span class="hljs-tag">&lt;/<span class="hljs-name">relation</span>&gt;</span>
 ...
<span class="hljs-tag">&lt;/<span class="hljs-name">osm</span>&gt;</span></code></pre>
<p>OSM представляє фізичні особливості на місцях (наприклад, дороги чи будівлі), використовуючи теги,
прикріплені до основних структур даних.
Кожен тег описує географічний атрибут функції, який відображається цим конкретним вузлом, відрізком чи зв&#39;язком.
Дозволяється включати необмежену кількість атрибутів, що описують кожну функцію. Співтовариство погоджується на певні поєднання ключів і значень для найбіль часто використовуваних тегів, які виступають як неофіційні стандарти.
Однак користувачі можуть створювати нові теги для вдосконалення стилю карти або для розширення описового апарату.</p>
<h3 id="опис-проблем-неправильної-геометрії-та-точності-обрахунків">Опис проблем неправильної геометрії та точності обрахунків</h3>
<p>Геоінформаційні системи не можуть правильно працювати у випадку коли використовується неправильна геометрія.
Для прикладу можна привести ситуацію з багатокутникои (полігоном). Дійсний багатокутник не може мати зовнішніх або внутрішніх кілець, що пересікаються. Також мультиполігон не може містити полігони які пересікаються. Всі операції (пересічення, віднімання) на неправильній геометрії можуть закінчуватись з помилкою.</p>
<p>Через подібні проблеми робота з геопросторовими даними дещо ускладнюється, бо доводиться постійно слідкувати аби після кожної операції утворювалась правильна геометрія. Існують методи для виправлення деяких випадків неправильної геометрії які дають очікуваний результат (інколи ці методи призводять до втрати частини геометричної інформації). Інший варіант обробки неправильної геометрії полягає у фільтрації таких об&#39;єктів, але це призводить до повної втрати інформації, тому пріоритет завжди надається виправленню неправильної геометрії.</p>
<p>Ще однією проблемою, є неточність обрахунків. Часто в геоінформаційних системах після проведення низки геометричних операцій вирахувані координати можуть мати похибку обчислень (це загальновідома проблема похибки обчислень в операціях з плаваючою точкою). Такі похибки і можуть спричиняти накладання полігонів, або ж утворення &quot;прогалин&quot; між ними, що є небажаним результатом.</p>
<p>Головну складність в процесі виправлення геометрії складає те, що в кожному випадку потрібно самостійно вирішувати який метод виправлення може спрацювати найкраще для вирішення поставленого завдання.</p>
<h3 id="методи-оптимізація-швидкості-обрахунків-геопросторових-даних-індексація">Методи оптимізація швидкості обрахунків геопросторових даних, індексація</h3>
<p>Через значні об&#39;єми геопросторової інформації та особливості роботи геометричних операцій, виникла необхідність вирішувати проблеми пов&#39;язані зі швидким ростом складності обрахунків.</p>
<p>Для прикладу розмітка деяких полігональних об&#39;єктів налічує більше мільйона точок, це призводить до значного сповільнення роботи операцій пересічення та віднімання. Аби впоратись з цією проблемою найчастіше використовують розбиття цього полігону на меньші (триангуляція або інший спосіб розбиття). Мінусом у цьому випадку є ускладнення логіки роботи з такими об&#39;єктами та ріст кількості об&#39;єктів. Тому важливо вдало підібрати спосіб розбиття де буде збалансовано кількість утворених об&#39;єктів та їхня деталізація (кількість вершин кожного полігону).</p>
<p>У зв&#39;язку з великою кількістю об&#39;єктів, при проведенні операцій над ними, часто використовують індекси. Це допомагає скоротити кількість обчислень, адже не доводиться проводити ці операції повним перебором. Зазвичай для цього використовують деревовидні структури (дерево квадрантів, R-дерево і тд.). Найчастіше використовують варіації R-дерева.</p>
<p><strong>R-дерево</strong> — деревоподібна структура даних, яка використовується для організації доступу до просторових даних, тобто для індексації багатовимірної інформації, такої, наприклад, як географічні координати, прямокутники або многокутники. R-дерево було запропоноване в 1984 році Антоніном Гуттманном і знайшло значне застосування як у теоретичному, так і у прикладному аспектах.</p>
<p>У випадку двовимірного простору, ця структура даних розбиває простір на множину ієрархічно вкладених прямокутників, які можуть перетинатись. У разі тривимірного або багатовимірного простору це будуть прямокутні паралелепіпеди.</p>
<p><div class="lazyload" style="padding-bottom: 100%" data-bg="url(/assets/optimized-img/rtree.png)" title="Візуалізація R*-дерева для 3D"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/rtree.png"></a></div></p>
<p>Алгоритми вставки і видалення використовують ці обмежуючі прямокутники для забезпечення того, щоб &quot;близько розташовані&quot; об&#39;єкти були поміщені в одну листову вершину. Зокрема, новий об&#39;єкт потрапить у ту листову вершину, для якої потрібно найменше розширення її прямокутника. Кожен елемент листової вершини зберігає два поля даних: спосіб ідентифікації даних, що описують об&#39;єкт, (або самі ці дані) і прямокутник, який обмежує цей об&#39;єкт.</p>
<p>В поєднанні ці два методи (метод розбиття та метод індексації) дозволяють значно оптимізувати швидкість виконання геометричних операцій. Недоліком зазвичай є ріст використання пам&#39;яті комп&#39;ютера для організації збереження цих структур.</p>
<h3 id="картографічні-проекції-та-їх-недоліки">Картографічні проекції та їх недоліки</h3>
<p><strong>Картографічні проекції</strong> — математичні способи зображення земного сфероїда на площині, при яких кожній точці M зображуваної поверхні відповідає точка M&#39;, яка називається її зображенням на площині. У картографічній проекції меридіани і паралелі зображено системою прямих чи плоских кривих ліній. За характером спотворень картографічні проекції поділяють на рівнокутні, рівновеликі та довільні. За видом зображень нормальної картографічної сітки — на азимутальні, циліндричні, конічні, псевдоконічні, псевдоциліндричні, поліконічні та псевдоазимутальні.</p>
<p>Будь-яка проекція має спотворення, воно буває чотирьох видів:</p>
<ul>
<li>Спотворення довжин</li>
<li>Спотворення кутів</li>
<li>Спотворення площ</li>
<li>Спотворення форм</li>
</ul>
<p>На різних картах спотворення можуть бути різних розмірів: на великомасштабних вони практично непомітні, а на маломасштабних, вони бувають дуже суттєві.</p>
<p>У цій роботі використано дві проекції:</p>
<ul>
<li><p>Світова геодезична система (WGS 84) — стандартизована координатна система на Землі, яка розроблена та підтримується Геопросторово-розвідувальною агенцією США.</p>
</li>
<li><p>Рівнокутна циліндрична проекція Меркатора — одна з основних картографічних проекцій. Розроблена Герардом Меркатором для застосування в його &quot;Атласі&quot;.</p>
</li>
</ul>
<p>Необхідність використання цих проекцій випливає з особливостей представлення геопросторових даних ресурсу OSM.</p>
<h3 id="інструменти-для-роботи-з-геопросторовими-даними">Інструменти для роботи з геопросторовими даними</h3>
<p>Робити опис всього спектру геоінформаційних технологій нема сенсу, тому акцент зроблено лише на тих технологіях які використано в розробці.</p>
<p><strong>API Overpass</strong> (раніше відомий як сценарій сторонніх серверів OSM або OSM3S до 2011 року) — це лише API для читання, який обслуговує вибрані частини даних карт OSM. Він діє як база даних відкрита для Інтернету: клієнт відправляє запит до API та отримує назад набір даних, що відповідає запиту.</p>
<p>На відміну від основного API, оптимізованого для редагування, API Overpass оптимізований для споживачів даних, яким потрібно отримати об&#39;єкти вибрані за критеріями пошуку, наприклад, розташування, тип об’єктів, властивості тегів, близькість або їх комбінації.
Для цього в API Overpass реалізована досить потужна мова запитів.</p>
<p>В екосистемі Python існує досить багато рішень з відкритим кодом для того щоб проводити операції над геопросторовими даними. Але найзручнішим та найшвидшим інструментом є бібліотека Shapely.</p>
<p><strong>Shapely</strong> — пакет Python для маніпуляцій та аналізу плоских геометричних об&#39;єктів. Це не стосується форматів даних або систем координат. Він базується на широко розгорнутих бібліотеках GEOS (двигун PostGIS) і JTS (з яких портується GEOS), використання яких дозволяє виконувати обчислення з високою швидкістю (адже це низькорівневі розширення написані на мові C).</p>
<p><strong>QGIS</strong> (раніше відомий як &quot;Quantum GIS&quot;) — вільна крос-платформена геоінформаційна система. QGIS є однією з найбільш функціональних і зручних настільних геоінформаційних систем та динамічно розвиваються.
Основним призначенням системи є обробка і аналіз просторових даних, підготовка різної картографічної продукції. Інтерфейс QGIS побудований на базі бібліотеки Qt. Пакет має гнучку систему розширень, які можна створювати на мовах С++ і Python. Підтримуються різноманітні векторні і растрові формати.
QGIS можна використовувати як для візуалізації так і для проведення обчислень, завдяки підримці плагінів на Python.</p>
<p><strong>Osm2geojson</strong> — пакунок Python для перетворення XML завантаженого з OSM в геометрію GeoJSON або об&#39;єкти геометрії Shapely. Цю бібліотеку було розроблено та опубліковано у вільний доступ в процесі роботи над поставленою задаче. Перевагою цієї бібліотеки є простота встановлення та використання. Крім XML формату який надає OSM у бібліотеці реалізована підтримка форматів Overpass XML/JSON, що значно спрощує роботу у випадках, коли потрібно отримати відфільтровану певним запитом геометрію.</p>
<h3 id="формати-збереження-геопросторових-даних">Формати збереження геопросторових даних</h3>
<p>Геопросторову інформацію зазвичай зберігають у вигляді файлів (датасетів) та в різноманітних базах даних (найпопулярнішим рішенням є розширення PostGIS для PostgreSQL).</p>
<p>Вище вже було описано відкритий формат OSM, згадано формат GeoJSON, але спектр різноманітрих форматів представлення та збереження геопросторової інформації настільки великий, що складно буде помістити сюди навіть перелік. Та у цій сфері можна виділити найпопулярніші формати, серед яких Shapefile та GeoJSON для збереження векторної інформації, а GeoTIFF. Варто зазначити, що у кожного формату є свої плюси та мінуси і ефективність використання кожного залежить від конкретного завдання.</p>
<p><strong>Shapefile</strong> — популярний векторний формат файлів, розробляється та підтримується компанією ESRI з метою сумісності даних між продуктами ESRI та стороннім програмним забезпеченням. Формат файлу дозволяє зберігати наступні типи геометричних фігур: точки, лінії, полігони. Кожен елемент, як правило, має атрибути, які описують його, такі як ім&#39;я, температура і тд.</p>
<p><strong>GeoJSON</strong> — відкритий формат призначений для зберігання географічних структур даних, заснований на JSON.
Формат може зберігати примітивні типи для опису географічних об&#39;єктів, такі як: точки (адреси та місця розташування), лінії (вулиці, шосе, кордони), полігони (країни, штати, ділянки землі). Також можуть зберігатися так звані мультитипи, які представляють собою об&#39;єднання декількох примітивних типів.
Формат GeoJSON відрізняється від інших стандартів ГІС тим, що він був написаний і підтримується не організацією зі стандартизації, а за допомогою робочої групи розробників.
Подальшим розвитком GeoJSON є TopoJSON, розширення GeoJSON, яке кодує геопросторову топологію, і, як правило, забезпечує менший розмір файлів.</p>
<p>У випадку представлення векторної геопросторової інформації найпопулярнішим форматом можна вважати Shapefile, у якого досить багато обмежень та мінусів. Використання GeoJSON вирішую велику частину цих проблем, але при цьому розмір GeoJSON файлів значно перевищує будь-який бінарний формат. Напевно найкращим рішенням для збереження об&#39;ємних наборів геопросторової інформації у більшості випадків є GeoPackage.</p>
<p><strong>GeoPackage</strong> (GPKG) — це відкритий, непатентований, незалежний від платформи та заснований на стандартах формат даних для географічної інформаційної системи, реалізований як контейнер бази даних SQLite. Визначений Консорціумом відкритого геопросторового простору (OGC) за підтримки американських військових та опублікований у 2014 році. GeoPackage отримав широку підтримку з боку різних урядових, комерційних та відкритих організацій.</p>
<h2 id="розділ-3-реалізація">Розділ 3. Реалізація</h2>
<p>Етапи реалізації алгоритму можна умовно розділити на:</p>
<ul>
<li>Завантаження необхідної інформації</li>
<li>Формування шарів геометрії</li>
<li>Реалізація &quot;простого&quot; алгоритму</li>
<li>Реалізація алгоритму з об&#39;єднанням доріг</li>
<li>Реалізація алгоритму зі згладжуванням некласифікованих зон</li>
<li>Оптимізація виконання алгоритму</li>
</ul>
<p>Налагодження та виправлення помилок не можна виділити як окремий етап, так як цей процес необхідно виконувати на кожному етапі.</p>
<h3 id="завантаження-даних-з-osm">Завантаження даних з OSM</h3>
<p>Щоб сформувати необхідну геометрію з відкритих даних OSM було реалізовано (та опубліковано в відкритий доступ) бібліотеку <a href="https://github.com/aspectumapp/osm2geojson" target="_blank" rel="noopener" >osm2geojson</a>, яка перетворює OSM/Overpass XML в геометрію Shapely або GeoJSON.
Звичайно, можна скористатись бібліотекою GDAL, але процес встановлення занадто складний і через особливості роботи бібліотеки GDAL з файловою системою її використання значно знижує швидкість роботи алгоритму.</p>
<p>Отож отримання межі міста відбувається простим запитом до API Overpass:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_city_border</span><span class="hljs-params">(city_id)</span>:</span>
  data = overpass_call(<span class="hljs-string">f"""
    rel(<span class="hljs-subst">{city_id}</span>);
    out geom;
  """</span>) <span class="hljs-comment"># returns xml-string</span>
  data = xml2geojson(data)

  <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> data[<span class="hljs-string">'features'</span>]:
    <span class="hljs-keyword">if</span> f[<span class="hljs-string">'properties'</span>][<span class="hljs-string">'tags'</span>][<span class="hljs-string">'type'</span>] == <span class="hljs-string">'boundary'</span>:
      <span class="hljs-keyword">return</span> f
  <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre>
<p>Для отримання набору доріг запит уже складніший:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_roads</span><span class="hljs-params">(minlat, minlon, maxlat, maxlon)</span>:</span>
  bb = <span class="hljs-string">f"(<span class="hljs-subst">{minlat}</span>, <span class="hljs-subst">{minlon}</span>, <span class="hljs-subst">{maxlat}</span>, <span class="hljs-subst">{maxlon}</span>)"</span>
  data = overpass_call(<span class="hljs-string">f"""
    way[highway~"^motorway$|^trunk$|^primary$|^secondary$|^tertiary$|^residential$"]<span class="hljs-subst">{bb}</span>;
    out geom;
  """</span>)
  <span class="hljs-keyword">return</span> xml2geojson(data)[<span class="hljs-string">'features'</span>]</code></pre>
<p>Завантаження водних об’єктів відбувається з допомогою досить великого запиту, адже там зустрічається як лінійна геометрія так і полігональна.</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_water_zones</span><span class="hljs-params">(minlat, minlon, maxlat, maxlon)</span>:</span>
  bb = <span class="hljs-string">f"(<span class="hljs-subst">{minlat}</span>, <span class="hljs-subst">{minlon}</span>, <span class="hljs-subst">{maxlat}</span>, <span class="hljs-subst">{maxlon}</span>)"</span>
  data = overpass_call(<span class="hljs-string">f"""
    (
      way[waterway~"^river$|^stream$|^riverbank$"]<span class="hljs-subst">{bb}</span>;
      way[landuse=basin]<span class="hljs-subst">{bb}</span>;
      way[natural=water]<span class="hljs-subst">{bb}</span>;
      way[water]<span class="hljs-subst">{bb}</span>;
      rel[landuse=basin]<span class="hljs-subst">{bb}</span>;
      rel[natural=water]<span class="hljs-subst">{bb}</span>;
      rel[water]<span class="hljs-subst">{bb}</span>;
      rel[waterway=riverbank]<span class="hljs-subst">{bb}</span>;
      &lt;;
    );
    out geom;
  """</span>)
  <span class="hljs-keyword">return</span> xml2geojson(data)[<span class="hljs-string">'features'</span>]</code></pre>
<p>Інформацію про берегову лінію можна завантажити вручну (адже це один датасет для всієї планети), але корисно мати для цього код, який завантажує та кешує цей датасет, адже він може змінюватись.
Після завантаження датасету, його потрібно розархівувати та отримати геометрію:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_coastline</span><span class="hljs-params">()</span>:</span>
  print(<span class="hljs-string">'Loading coastline to memory ...'</span>)
  coastline_zip = get_coastline_file() <span class="hljs-comment"># returns abs path to zip file with dataset</span>
  coastline_dir = coastline_zip.replace(<span class="hljs-string">'.zip'</span>, <span class="hljs-string">''</span>)
  coastline_file = os.path.join(coastline_dir, <span class="hljs-string">'land_polygons.shp'</span>)

  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(coastline_file):
    r = zipfile.ZipFile(coastline_zip, <span class="hljs-string">'r'</span>)
    r.extractall(config.CACHE_DIR)
    r.close()

  data = geopandas.read_file(coastline_file)
  print(<span class="hljs-string">'Coastline loaded!'</span>)
  <span class="hljs-keyword">return</span> data</code></pre>
<h3 id="формування-початкової-геометрії">Формування початкової геометрії</h3>
<p>Як було сказано раніше, робота з лінійною та полігональною геометріями відрізняється — адже полігони займають певну площу, а от для лінійної геометрію цю площу потрібно якось побудувати — перетворити лінію на полігон певного розміру, який би відповідав розмірам реального об’єкту.
Аби зробити це перетворення можна використати операцію буферизації — грубо кажучи це розширення лінії.
В документації Shapely більше деталей по роботі цього методу <a href="https://shapely.readthedocs.io/en/stable/manual.html#object.buffer" target="_blank" rel="noopener" >shapely/object.buffer</a>.</p>
<p>З підбором розміру цього буферу теж все доволі просто — для різних видів доріг в OSM є свої теги і детальний опис як їх потрібно використовувати, наприклад, для доріг в Україні можна скористатись класифікацією з <a href="https://wiki.openstreetmap.org/wiki/Uk:%D0%92%D1%96%D0%BA%D1%96%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82_%D0%A3%D0%BA%D1%80%D0%B0%D1%97%D0%BD%D0%B0/%D0%9A%D0%BB%D0%B0%D1%81%D0%B8%D1%84%D1%96%D0%BA%D0%B0%D1%86%D1%96%D1%8F_%D0%B4%D0%BE%D1%80%D1%96%D0%B3" target="_blank" rel="noopener" >вікі OSM</a> (для інших країн теж існують подібні класифікації).
А самі значення розміру дорожньої смуги можна знайти в державних стандартах (для більшості країн значення часто однакові).</p>
<p>Для побудови буферів слугує функція build_buffer_on_lines, яка виконує побудову квадратного буферу.
Цей вид буферу найкраще підходить для нашого випадку (по якості результату та кількості обчислень).</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">build_buffer_on_lines</span><span class="hljs-params">(lines, b_size)</span>:</span>
  buffers = []
  <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines:
    b = line.buffer(b_size, cap_style=<span class="hljs-number">3</span>, join_style=<span class="hljs-number">2</span>, mitre_limit=<span class="hljs-number">1</span>)
    buffers.append(b)
  <span class="hljs-keyword">return</span> array_to_multipolygon(buffers)</code></pre>
<p>Приклад перетворення geojson в геометрію shapely найкраще проілюстровано в формуванні зон водної території:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_water_features_to_zones</span><span class="hljs-params">(geoms)</span>:</span>
  water_zones = []
  lines = []
  <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> geoms:
    shape = geometry.shape(item[<span class="hljs-string">'geometry'</span>])
    <span class="hljs-keyword">if</span> isinstance(shape, geometry.LineString) <span class="hljs-keyword">or</span> isinstance(shape, geometry.MultiLineString):
      lines.append(shape)
    <span class="hljs-keyword">if</span> isinstance(shape, geometry.Polygon) <span class="hljs-keyword">or</span> isinstance(shape, geometry.MultiPolygon):
      water_zones.append(shape)

  rivers = build_buffer_on_lines(lines, buffer_sizes[<span class="hljs-string">'river'</span>])
  water_zones.append(rivers)
  <span class="hljs-keyword">return</span> ops.cascaded_union(water_zones)</code></pre>
<p>Геометрію по якій буде проводитись класифікації зон міста можна завантажити зробивши схожий запит, але уже без фільтрації за властивостями об&#39;єктів.</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_all_geometry</span><span class="hljs-params">(minlat, minlon, maxlat, maxlon)</span>:</span>
  query = <span class="hljs-string">f"(node(<span class="hljs-subst">{minlat}</span>, <span class="hljs-subst">{minlon}</span>, <span class="hljs-subst">{maxlat}</span>, <span class="hljs-subst">{maxlon}</span>);&lt;;); out geom;"</span><span class="hljs-string">""</span>
  data = overpass_call(query)

  features = []
  <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> xml2geojson(data)[<span class="hljs-string">'features'</span>]:
    <span class="hljs-keyword">if</span> item[<span class="hljs-string">'geometry'</span>][<span class="hljs-string">'type'</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">'Polygon'</span>, <span class="hljs-string">'MultiPolygon'</span>]:
      cls = detect_class(item) <span class="hljs-comment"># here some magic</span>
    <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:
      <span class="hljs-keyword">continue</span>
    item[<span class="hljs-string">'properties'</span>][<span class="hljs-string">'class'</span>] = cls
    features.append(item)
  <span class="hljs-keyword">return</span> features</code></pre>
<p>В цьому коді було використано метод <code>detect_class</code>, деталі реалізації якого буде описано в наступному пункті.</p>
<p>В результаті цих операцій ми отримуємо початкові набори геометрії (на прикладі міста Київ):</p>
<ul>
<li>Межа міста (border)</li>
</ul>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/border.png)" title="Межа міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/border.png"></a></div></p>
<ul>
<li>Мультиполігон звичайних дорожніх шляхів (roads)</li>
</ul>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/roads-kiev.png)" title="Дороги міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/roads-kiev.png"></a></div></p>
<ul>
<li>Мультиполігон залізничних шляхів (railways)</li>
</ul>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/railways-kiev.png)" title="Залізничні шляхи міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/railways-kiev.png"></a></div></p>
<ul>
<li>Мультиполігон водних об’єктів (water_zones)</li>
</ul>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/water-kiev.png)" title="Водні об&#39;єкти міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/water-kiev.png"></a></div></p>
<ul>
<li>Вся інша геометрія, по якій буде проводитись класифікація, згрупована за цільовим набором класів (all_geometry_by_class)</li>
</ul>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/classified-geom.png)" title="Класифікована геометрія міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/classified-geom.png"></a></div></p>
<h3 id="простий-алгоритм">“Простий” алгоритм</h3>
<p>Для того щоб побудувати звичайну карту потрібно на межу міста накласти всю іншу геометрію з урахуванням пріоритетів.
Визначення пріоритетності кожного класу не зовсім очевидне завдання, наприклад водні об’єкти мають найнижчий пріоритет, бо зазвичай дорожні та залізничні шляхи проходять над річками і т.д..</p>
<p>А от з дорогами та залізницею все трохи складніше, бо дорожні мости можуть проходити над залізничними шляхами, так і навпаки — залізничні мости над дорожніми шляхами.
Але все ж краще виявилось надавати дорогам вищий пріоритет (кількість правильно розміченої території буде більша).
Є і більш складна схема розподілу отриманої геометрії на шари, яка описана тут <a href="https://wiki.openstreetmap.org/wiki/Key:layer" target="_blank" rel="noopener" >wiki.osm/Key:layer</a>.
Мінусом цього підходу у нашому випадку — значний ріст кількості обчислень.</p>
<p><div class="lazyload" style="padding-bottom: 100%" data-bg="url(/assets/optimized-img/layers.png)" title="Результат накладання шарів"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/layers.png"></a></div></p>
<p>Одним з важливих етапів в обрахунках є етап оптимізації геометрії.
Необхідність цього виникає по причині надзвичайно великих полігонів доріг та водних об’єктів (інколи сітка доріг покриває ледь не все місто і формує один полігон).
Використання такої геометрії призводить до неконтрольованого росту складності обчислень (на великих містах це може займати кілька діб).
Щоб позбутись цієї проблеми можна просто розбивати великі полігони на менші. Рішення аналогічної проблеми описано в цій <a href="https://snorfalorpagus.net/blog/2016/03/13/splitting-large-polygons-for-faster-intersections/" target="_blank" rel="noopener" >статті</a>. Де запропоновано алгоритм адаптивного розбиття полігонів на менші полігони.
Саме цей алгоритм розбиття і було використано в роботі.</p>
<p>Ще одна важлива частина оптимізації це побудова індексу над наборами полігонів (детальніше про це можна почитати в <a href="https://geoffboeing.com/2016/10/r-tree-spatial-index-python/" target="_blank" rel="noopener" >цій статті</a>).
В бібліотеці Shapely вже вбудований хороший алгоритм для індексації геометрії STRtree (Sort-Tile-Recursive algorithm).
Код для обчислення пересічення та різниці полігонів трохи ускладниться (бо потрібно додати етап індексації та пошуку полігонів у індексі), але досить просто виділити ці операції в окремі методи</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">optimized_intersection</span><span class="hljs-params">(a, b)</span>:</span>
  a_opt = katana(a, split_size)
  b_opt = katana(b, split_size)
  a_tree = STRtree(a_opt)

  parts = []
  <span class="hljs-keyword">for</span> zone <span class="hljs-keyword">in</span> b_opt:
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> a_tree.query(zone):
      intersection =  p.intersection(zone)
      <span class="hljs-keyword">if</span> intersection.area &gt; <span class="hljs-number">0</span>:
        parts.append(intersection)

  <span class="hljs-keyword">return</span> array_to_multipolygon(parts)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">optimized_difference</span><span class="hljs-params">(a, b)</span>:</span>
  a_opt = katana(a, split_size)
  b_opt = katana(b, split_size)
  b_tree = STRtree(b_opt)

  parts = []
  <span class="hljs-keyword">for</span> zone <span class="hljs-keyword">in</span> a_opt:
    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> b_tree.query(zone):
      zone = zone.difference(p)
      parts.append(zone)

  <span class="hljs-keyword">return</span> array_to_multipolygon(parts)</code></pre>
<p>Після цього можна безпосередньо переходити до логіки алгоритму:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_simple_zones</span><span class="hljs-params">(border, roads, railways, water_zones)</span>:</span>
  roads_in_city = optimized_intersection(roads, border)
  railways_in_city = optimized_intersection(railways, border)
  water_zones_in_city = optimized_intersection(water_zones, border)

  water_zones_fixed = optimized_difference(water_zones_in_city, roads_in_city)
  water_zones_fixed = optimized_difference(water_zones_fixed, railways_in_city)

  city_zones = optimized_difference(border, roads)
  city_zones = optimized_difference(city_zones, railways)
  city_zones = optimized_difference(city_zones, water_zones)

  railways_without_roads = optimized_difference(railways_in_city, roads_in_city)

  features = multipolygon_to_features(roads_in_city, <span class="hljs-string">'roads'</span>)
  features += multipolygon_to_features(water_zones_fixed, <span class="hljs-string">'water'</span>)
  features += multipolygon_to_features(railways_without_roads, <span class="hljs-string">'railways'</span>)
  features += multipolygon_to_features(city_zones)

  <span class="hljs-keyword">return</span> features</code></pre>
<p>В результаті виконання цього коду можна отримати набір полігонів (в GeoJSON), які сегментують територію міста.
Але кінцева ціль — отримати класифіковані зони міста, тому полігони які ще не мають класу потрібно якось класифікувати (зони доріг, залізниці та водних об’єктів було отримано на попередніх етапах).</p>
<p>Маючи набір некласифікованих зон можна провести їхню класифікацію вирахувавши площу пересічення з іншими полігонами OSM (які до цього було завантажено та прокласифіковано).</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">classify_features</span><span class="hljs-params">(features, all_geometry_by_class)</span>:</span>
  geometry_index = {}
  <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> all_geometry_by_class:
    geometry_index[cls] = STRtree(all_geometry_by_class[cls])

    <span class="hljs-keyword">for</span> feature <span class="hljs-keyword">in</span> features:
      <span class="hljs-keyword">if</span> <span class="hljs-string">'class'</span> <span class="hljs-keyword">in</span> f[<span class="hljs-string">'properties'</span>]:
        <span class="hljs-keyword">continue</span>

      shape = geometry.shape(feature[<span class="hljs-string">'geometry'</span>])
      <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> shape.is_valid:
        print(<span class="hljs-string">'Shape is invalid! Try to fix'</span>)
        shape = polygon_fix(shape)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> shape.is_valid:
          print(<span class="hljs-string">'Not fixed :('</span>, validation.explain_validity(shape))
          <span class="hljs-keyword">continue</span>

      probs = {}
      <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> geometry_index:
        probs[cls] = <span class="hljs-number">0</span>
        <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> geometry_index[cls].query(shape):
          <span class="hljs-keyword">if</span> s.is_valid:
            probs[cls] += shape.intersection(s).area

      detected_class = <span class="hljs-string">'Artificial Surfaces'</span> <span class="hljs-comment"># default class</span>
      max_area = <span class="hljs-number">0</span>
      <span class="hljs-keyword">for</span> cls <span class="hljs-keyword">in</span> probs:
        <span class="hljs-keyword">if</span> probs[cls] &gt; max_area:
          max_area = probs[cls]
          detected_class = cls

      feature[<span class="hljs-string">'properties'</span>] = {
        <span class="hljs-string">'class'</span>: detected_class,
        <span class="hljs-string">'probabilities'</span>: normalize(probs)
      }
  <span class="hljs-keyword">return</span> features</code></pre>
<p>Цікавою частиною тут є функція polygon_fix, яка часто допомагає впоратись з неправильною геометрією.</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">polygon_fix</span><span class="hljs-params">(polygon)</span>:</span>
  be = polygon.exterior
  mls = be.intersection(be)
  polygons = ops.polygonize(mls)
  <span class="hljs-keyword">return</span> geometry.MultiPolygon(polygons)</code></pre>
<p>На цьому основна частина алгоритму закінчується, а класифіковану геометрію можна зберегти в файл аби десь візуалізувати.</p>
<p>Візуалізація для міста Київ з використанням QGIS</p>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/kiev-simple.png)" title="Класифіковані зони міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/kiev-simple.png"></a></div></p>
<h3 id="алгоритм-з-обєднанням-доріг">Алгоритм з об’єднанням доріг</h3>
<p>Цей алгоритм майже не відрізняється від попереднього, відмінний лише етап утворення мультиполігонів доріг (звичайних та залізничних).
Аби цього досягнути потрібно замість звичайної побудови буферів робити буфер більшого розміру, а потім операцією віднімання буферу отримувати полігони потрібного розміру, при цьому дороги які були поряд стануть об’єднаними. Код який це робить:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_roads</span><span class="hljs-params">(polygon)</span>:</span>
  area = polygon.buffer(merge_buffer_size, cap_style=<span class="hljs-number">2</span>, join_style=<span class="hljs-number">2</span>, mitre_limit=<span class="hljs-number">1</span>)
  <span class="hljs-keyword">return</span> area.buffer(-merge_buffer_size, cap_style=<span class="hljs-number">2</span>, join_style=<span class="hljs-number">2</span>, mitre_limit=<span class="hljs-number">1</span>)</code></pre>
<p>Різницю в геометрії, що генерується, можна побачити на зображенні.</p>
<p><div class="lazyload" style="padding-bottom: 47.45347698334966%" data-bg="url(/assets/optimized-img/kiev-compare-geom.png)" title="Порівняння простої геометрії та після об&#39;єднання"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/kiev-compare-geom.png"></a></div></p>
<p>А повне зображення для міста Київ:</p>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/kiev-merged.png)" title="Зони міста Київ з об&#39;єднаними дорогами"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/kiev-merged.png"></a></div></p>
<h3 id="алгоритм-зі-згладжуванням-зон">Алгоритм зі згладжуванням зон</h3>
<p>Деколи високе “засмічення” карти дорогами є небажаним результатом (наприклад візуально це погано сприймається).
Для цього знову можна використати операцію з додаванням та відніманням буферу — для кожної зони потрібно спершу додати буфер, а потім відняти буфер такого ж розміру.
Але через важливість збереження основних ліній доріг (потрібно видалити лише сліпі дороги) алгоритм дещо ускладниться</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">compute_smoothed_zones</span><span class="hljs-params">(border, roads, railways, water_zones)</span>:</span>
  smooth_city_zones_by_roads = make_smooth_zones(optimized_difference(border, roads))
  other_zones_by_roads = optimized_difference(border, smooth_city_zones_by_roads)
  smoothed_roads = optimized_intersection(roads, other_zones_by_roads)
  roads_in_city = optimized_intersection(smoothed_roads, border)

  smooth_city_zones_by_railways = make_smooth_zones(optimized_difference(border, railways))
  other_zones_by_railways = optimized_difference(border, smooth_city_zones_by_railways)
  smoothed_railways = optimized_intersection(railways, other_zones_by_railways)
  railways_in_city = optimized_difference(smoothed_railways, smoothed_roads)

  water_zones_in_city = optimized_intersection(water_zones, border)
  water_zones_in_city = optimized_difference(water_zones_in_city, roads_in_city)
  water_zones_in_city = optimized_difference(water_zones_in_city, railways_in_city)

  smooth_city_zones = optimized_difference(border, smoothed_roads)
  smooth_city_zones = optimized_difference(smooth_city_zones, smoothed_railways)
  smooth_city_zones = optimized_difference(smooth_city_zones, water_zones)

  features = multipolygon_to_features(roads_in_city, <span class="hljs-string">'roads'</span>)
  features += multipolygon_to_features(railways_in_city, <span class="hljs-string">'railways'</span>)
  features += multipolygon_to_features(water_zones_in_city, <span class="hljs-string">'water'</span>)
  features += multipolygon_to_features(smooth_city_zones)

  <span class="hljs-keyword">return</span> features</code></pre>
<p>Як помітно з коду, появилась нова функція — make_smooth_zones.
Саме вона і займається побудовою буферів і виправленням згенерованої геометрії (інколи зони накладаються одна на одну і потрібно робити додаткове віднімання між полігонами зон аби утворити правильний мультиполігон)</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">make_smooth_zones</span><span class="hljs-params">(city_zones)</span>:</span>
  zones_polygons = []
  <span class="hljs-keyword">if</span> isinstance(city_zones, geometry.Polygon):
    zones_polygons.append(city_zones)
  <span class="hljs-keyword">else</span>:
    <span class="hljs-keyword">for</span> poly <span class="hljs-keyword">in</span> city_zones.geoms:
      zones_polygons.append(
        poly
        .buffer(merge_buffer_size, cap_style=<span class="hljs-number">3</span>, join_style=<span class="hljs-number">2</span>, mitre_limit=<span class="hljs-number">1</span>)
        .buffer(-merge_buffer_size, cap_style=<span class="hljs-number">2</span>, join_style=<span class="hljs-number">2</span>, mitre_limit=<span class="hljs-number">1</span>)
      )

  zonesTree = STRtree(zones_polygons)
  <span class="hljs-keyword">for</span> idx, zone <span class="hljs-keyword">in</span> enumerate(zones_polygons):
    found = zonesTree.query(zone)
    <span class="hljs-keyword">for</span> z <span class="hljs-keyword">in</span> found:
      <span class="hljs-keyword">if</span> zone.intersects(z):
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> z <span class="hljs-keyword">is</span> zone <span class="hljs-keyword">and</span> zone.intersection(z).area &gt; <span class="hljs-number">0</span>:
          zones_polygons[idx] = zone.difference(z.buffer(<span class="hljs-number">0.000001</span>, cap_style=<span class="hljs-number">2</span>, join_style=<span class="hljs-number">2</span>, mitre_limit=<span class="hljs-number">1</span>))

  <span class="hljs-keyword">return</span> geometry.MultiPolygon(zones_polygons)</code></pre>
<p>Результат згладжування</p>
<p><div class="lazyload" style="padding-bottom: 94.90695396669932%" data-bg="url(/assets/optimized-img/kiev.png)" title="Згладжені зони міста Київ"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/kiev.png"></a></div></p>
<h3 id="класифікація-завантаженої-геометрії-з-osm">Класифікація завантаженої геометрії з OSM</h3>
<p>Вище було вже згадано, що завантажену геометрію з OSM потрібно класифікувати, аби потім була можливість вираховувати площі пересічень з утвореними некласифікованими зонами міст.</p>
<p>Для розуміння повної структури стандарту OSM краще скористатись документацією стандарту (в нашому випадку потрібно також ознайомитись і з особливостями формату даних Overpass), але основні пункти буде описано тут.</p>
<p>Кожен геометричний об&#39;єкт OSM поряд з просторовою інформацією несе також мета-дані, а саме набір властивостей ключ:значення, які покликані відобразити господарське призначення тих чи інших об&#39;єктів, їхні властивості та інше. Перерахувати всі ці властивості буде складно, але для прикладу вище в коді запиту на завантаження геометрії яка описує водні об&#39;єкти можна було помітити набір фільтрів, де і були записані такі пари ключ:значення які присвоюють саме для водних об&#39;єктів: landuse=basin, landuse=water і тд.</p>
<p>Основні види геометрії формату OSM це: точки, лінії та полігони. Але у випадку задачі класифікації зон доцільно використовувати саме полігональну геометрію. Для ліній та точок теж можна надати розмір (утворивши буфер), але для кожного виду таких об&#39;єктів потрібно було б визначати цей розмір, що зайняло б дуже багато часу та зусиль, а вплив на якість результату був би мінімальним.</p>
<p>Аби провести класифікацію всього різноманіття завантаженої геометрії було сформовано файл конфігурації, який зберігає набір пар ключ:значення, які відповідають вже цільвому набору класів. Приклад частини цього файлу:</p>
<pre><code data-lang="json" class="hljs">{
  "Artificial Surfaces": [
    {
      "key": "amenity",
      "values": [
        "animal_shelter",
        "arts_centre",
        "bank",
        "bar",
        "cafe",
        ...
      ]
    },
    {
      "key": "building",
      "values": [...]
    },
    ...
  ],
  "Forests": [...],
  ...
}</code></pre>
<p>Маючи цю конфігурацію, доволі просто знайти до якого класу відноситься об&#39;єкт зіставивши значення властивостей об&#39;єкту зі значеннями описаними в конфігурації.</p>
<p>Використання такої конфігурації дозволяє гнучко змінувати цільовий набір класів та властивості які характеризують кожен клас.</p>
<p>Далі приведено код для завантаження конфігурації в пам&#39;ять та класифікації об&#39;єкту OSM відповідно.</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_osm_classes</span><span class="hljs-params">()</span>:</span>
    osm_classes = {}
    <span class="hljs-keyword">with</span> open(os.path.join(config.DIR, <span class="hljs-string">'osm-classes.json'</span>), encoding=<span class="hljs-string">'utf-8'</span>) <span class="hljs-keyword">as</span> data:
        data = json.load(data)
        <span class="hljs-keyword">for</span> label, items <span class="hljs-keyword">in</span> data.items():
            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> label <span class="hljs-keyword">in</span> osm_classes:
                osm_classes[label] = {}

            <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items:
                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> item[<span class="hljs-string">'key'</span>] <span class="hljs-keyword">in</span> osm_classes[label]:
                    osm_classes[label][item[<span class="hljs-string">'key'</span>]] = item[<span class="hljs-string">'values'</span>]
                <span class="hljs-keyword">else</span>:
                    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> item[<span class="hljs-string">'values'</span>]:
                        osm_classes[label][item[<span class="hljs-string">'key'</span>]].append(v)
    <span class="hljs-keyword">return</span> osm_classes

osm_classes = load_osm_classes()

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detect_class</span><span class="hljs-params">(f)</span>:</span>
    <span class="hljs-keyword">if</span> <span class="hljs-string">'tags'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> f[<span class="hljs-string">'properties'</span>]:
        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>

    <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> f[<span class="hljs-string">'properties'</span>][<span class="hljs-string">'tags'</span>].items():
        <span class="hljs-keyword">for</span> label, by_key <span class="hljs-keyword">in</span> osm_classes.items():
            <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> by_key <span class="hljs-keyword">and</span> value <span class="hljs-keyword">in</span> by_key[key]:
                <span class="hljs-keyword">return</span> label
    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre>
<h3 id="оптимізація-та-виконання-алгоритму">Оптимізація та виконання алгоритму</h3>
<p>Оскільки цей алгоритм виконує розмітку для міста, то логічно буде спробувати запустити його для декількох міст.
А в тому щоб робити це синхронно нема ніякої необхідності — найпростіше буде просто запустити виконання для кожного міста в окремому потоці.</p>
<p>Приклад коду який запускає обрахунки для кількох міст паралельно:</p>
<pre><code data-lang="python" class="hljs">city_ids = [
    <span class="hljs-number">395856</span>,
    <span class="hljs-number">421866</span>,
    <span class="hljs-number">439840</span>,
    ...
]
t_limit = Semaphore(multiprocessing.cpu_count())
pool = []
lock = Lock()

<span class="hljs-keyword">for</span> id <span class="hljs-keyword">in</span> city_ids:
    t = Thread(target=split_city, args=(id, lock, t_limit), name=<span class="hljs-string">f"city-<span class="hljs-subst">{id}</span>"</span>)
    pool.append(t)
    t.start()

<span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> pool:
    t.join()</code></pre>
<p>Тіло методу <code>split_city</code>, який і виконує всі три модифікацї алгоритму:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_city</span><span class="hljs-params">(id, lock, t_limit)</span>:</span>
    lock.acquire()
    <span class="hljs-keyword">try</span>:
        border, roads, railways, water_zones = load_projected_data(id)
    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:
        print(<span class="hljs-string">'Data for city not loaded'</span>, id, e)
        traceback.print_exc()
        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>
    <span class="hljs-keyword">finally</span>:
        lock.release()
    t_limit.acquire()

    zones_simple = compute_simple_zones(border, roads, railways, water_zones)
    zones_simple = project_features_to_polar(zones_simple)
    classify_and_save_items(zones_simple, id, <span class="hljs-string">f"data/city-<span class="hljs-subst">{id}</span>-simple.geojson"</span>)

    merged_roads_multipolygon = merge_roads(roads)
    merged_railways_multipolygon = merge_roads(railways)

    zones_merged = compute_merged_zones(border, merged_roads_multipolygon, merged_railways_multipolygon, water_zones)
    zones_merged = project_features_to_polar(zones_merged)
    classify_and_save_items(zones_merged, id, <span class="hljs-string">f"data/city-<span class="hljs-subst">{id}</span>-merged.geojson"</span>)

    zones_smoothed = compute_smoothed_zones(border, merged_roads_multipolygon, merged_railways_multipolygon, water_zones)
    zones_smoothed = project_features_to_polar(zones_smoothed)
    classify_and_save_items(zones_smoothed, id, <span class="hljs-string">f"data/city-<span class="hljs-subst">{id}</span>-smoothed.geojson"</span>)

    t_limit.release()
    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre>
<p>В результаті виконання цього коду буде утворено GeoJSON файли з класифікованими зонами для вказаних міст. Ці файли можна використовувати як датасет або візуалізувати (наприклад програмою QGIS).</p>
<p>Також велику частину обрахованої геометрії можна кешувати та зберігати на жорсткий диск, але потрібно враховувати те, що OSM постійно змінюється і про інвалідацію цього кешу забувати не треба.</p>
<p>Добре ілюструє підхід до кешування етап завантаження даних з OSM/Overpass. Вище в коді часто зустрічався метод <code>overpass_call</code>, який завантажує необхідну інформацію (згідно запиту) з Overpass:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">overpass_call</span><span class="hljs-params">(query)</span>:</span>
    encoded = urllib.parse.quote(query.encode(<span class="hljs-string">"utf-8"</span>), safe=<span class="hljs-string">'~()*!.\''</span>)
    r = requests.post(config.OVERPASS,
                      data=<span class="hljs-string">f"data=<span class="hljs-subst">{encoded}</span>"</span>,
                      headers={<span class="hljs-string">"Content-Type"</span>: <span class="hljs-string">"application/x-www-form-urlencoded;charset=UTF-8"</span>})
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> r.status_code <span class="hljs-keyword">is</span> <span class="hljs-number">200</span>:
        <span class="hljs-keyword">raise</span> requests.exceptions.HTTPError(<span class="hljs-string">'Overpass server respond with status '</span>+str(r.status_code))
    <span class="hljs-keyword">return</span> r.text</code></pre>
<p>В коді доволі просто замінити виклик цього методу на версію з вбудованим механізмом кешування:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cached_overpass_call</span><span class="hljs-params">(query)</span>:</span>
    name = os.path.join(config.CACHE_DIR, str(zlib.adler32(query.encode())) + <span class="hljs-string">'.osm'</span>)
    <span class="hljs-keyword">if</span> os.path.exists(name):
        <span class="hljs-keyword">with</span> codecs.open(name, <span class="hljs-string">'r'</span>, encoding=<span class="hljs-string">'utf8'</span>) <span class="hljs-keyword">as</span> data:
            <span class="hljs-keyword">return</span> data.read()
    data = overpass_call(query)
    save_file(data, name)
    <span class="hljs-keyword">return</span> data</code></pre>
<p>Мінусом такого кешування є етап інвалідації кешу — видаляти застарілу інформаціюю потрібно вручуну. Але у випадку цієї роботи необхідності в автоматичній інвалідації кешу немає, адже часто в процесі розробки виникають проблеми і проводити налагодження роботи алгоритму набагато простіше коли вхідні параметри (а саме датасети завантажені з OSM) не змінюються.</p>
<p>Ще одним місцем для оптимізації є інтерпретатор Python.
Значна кількість обчислень в бібліотеці Shapely і так винесена в нативне розширення (основними операціями з геометрією займається бібліотека GEOS, яка написана на C++).
Але в коді програми також є велика кількість обрахунків на стороні python.
На щастя не так складно виявилось реалізувати компіляцію всього коду в нативне розширення за допомогою <a href="https://cython.org/" target="_blank" rel="noopener" >Cython</a>.</p>
<h2 id="висновки">Висновки</h2>
<p>Використання відкритих векторних даних може дати непоганий результат, але в процесі часто виникають проблеми з неправильною геометрією та нерівномірністю розмітки.
В деяких задачах гостро встає проблема складності обрахунків і швидкодії.
Але в цій статті я намагався показати, як з цими проблемами можна впоратись.</p>
<p>Товариство OSM не стоїть на місці і постійно покращує свій продукт, що в свою чергу дозволяє на такому хорошому джерелі інформації проводити купу досліджень.
Різноманітність даних OSM дозволяє максимально детально класифікувати сформовані зони в межах населених пунктів, що можна розглянути як глобальний Urban Atlas.</p>
<p>Використання оглянутого підходу по сегментації не обмежується містами, а дозволяє формувати геометрії в будь-яких інших територіях з достатньо густою сіткою лінійної геометрії.</p>
<p>Розвиток ресурсу OSM забезпечує все більшу користь від використання методу, що надалі може повністю замінити ручну роботу для класифікації супутникових знімків.</p>
<p>В даній роботі було вирішено проблему сегментування урбанізованих територій з використання відкритих джерел інформації. При цьому було розлянуто сучасні інструменти та алгоритми для роботи з геопросторовими даними.</p>
<p>Результати роботи алгоритму збережено у вигляді векторної геометрії та візуалізовано у вигляді графічних карт.</p>
</main></div><footer>© Mikola Parfenyuck<div class="social-links"><a class="icon icon-twitter" rel="noopener" target="_blank" aria-label="My twitter" title="My twitter" href="https://twitter.com/i_rapkin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 72"><path d="M67.812 16.141a26.246 26.246 0 0 1-7.519 2.06 13.134 13.134 0 0 0 5.756-7.244 26.127 26.127 0 0 1-8.313 3.176A13.075 13.075 0 0 0 48.182 10c-7.229 0-13.092 5.861-13.092 13.093 0 1.026.118 2.021.338 2.981-10.885-.548-20.528-5.757-26.987-13.679a13.048 13.048 0 0 0-1.771 6.581c0 4.542 2.312 8.551 5.824 10.898a13.048 13.048 0 0 1-5.93-1.638c-.002.055-.002.11-.002.162 0 6.345 4.513 11.638 10.504 12.84a13.177 13.177 0 0 1-3.449.457c-.846 0-1.667-.078-2.465-.231 1.667 5.2 6.499 8.986 12.23 9.09a26.276 26.276 0 0 1-16.26 5.606A26.21 26.21 0 0 1 4 55.976a37.036 37.036 0 0 0 20.067 5.882c24.083 0 37.251-19.949 37.251-37.249 0-.566-.014-1.134-.039-1.694a26.597 26.597 0 0 0 6.533-6.774z"></path></svg>
</a><a class="icon icon-github" rel="noopener" target="_blank" aria-label="My github" title="My github" href="https://github.com/rapkin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
</a></div></footer><script src="/assets/js/bundle.js"></script></body></html>