<!DOCTYPE html><html lang="en"><head><title>[UKR] Рецепт навчання нейрнонних мереж - @rapkin</title><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="yandex-verification" content="39324391851d1a5d"/><meta name="google-site-verification" content="pnATuZP_aTcMjckmXnh2j6oO8Mk9YXUA7GfE7UO4QXk"/><link rel="stylesheet" href="/assets/css/site.css"/><meta property="og:type" content="article"/><meta property="og:site_name" content="@rapkin | Software developer"/><meta itemProp="name" content="[UKR] Рецепт навчання нейрнонних мереж"/><meta name="author" content="Mikola Parfenyuck"/><meta property="article:author" content="Mikola Parfenyuck"/><meta name="twitter:card" content="summary"/><meta name="twitter:site" content="@i_rapkin"/><meta name="description" content="Переклад статті A Recipe for Training Neural Networks. Перелік основних порад для початківців, що допоможуть ефективніше навчати нейронні мережі."/><meta itemProp="description" content="Переклад статті A Recipe for Training Neural Networks. Перелік основних порад для початківців, що допоможуть ефективніше навчати нейронні мережі."/><meta property="og:description" content="Переклад статті A Recipe for Training Neural Networks. Перелік основних порад для початківців, що допоможуть ефективніше навчати нейронні мережі."/><meta name="twitter:description" content="Переклад статті A Recipe for Training Neural Networks. Перелік основних порад для початківців, що допоможуть ефективніше навчати нейронні мережі."/><meta itemProp="image" content="https://rapkin.com.ua/assets/optimized-img/stonks-neural-networks.jpg"/><meta property="og:image" content="https://rapkin.com.ua/assets/optimized-img/stonks-neural-networks.jpg"/><meta name="twitter:image" content="https://rapkin.com.ua/assets/optimized-img/stonks-neural-networks.jpg"/><meta name="google" content="nositelinkssearchbox"/><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","author":"Mikola Parfenyuck","headline":"[UKR] Рецепт навчання нейрнонних мереж","datePublished":"2021-02-03T21:42:13.000Z","publisher":{"@type":"Organization","name":"rapkin","url":"https://rapkin.com.ua","logo":{"@type":"ImageObject","url":"https://rapkin.com.ua/assets/optimized-img/bunny.png"}},"image":"https://rapkin.com.ua/assets/optimized-img/stonks-neural-networks.jpg","name":"[UKR] Рецепт навчання нейрнонних мереж"}</script><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="preconnect" href="https://www.google-analytics.com"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/inconsolata-v18-latin-regular.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-italic.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-700.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-700italic.woff2" crossorigin="true"/><link rel="preload" as="font" type="font/woff2" href="/assets/fonts/literata-v13-cyrillic_latin-regular.woff2" crossorigin="true"/></head><body><div class="top"><header role="banner"><a class="logo" href="/">@rapkin</a><span class="logo-details">Software developer</span><ul class="menu-wrapper"><li><a class="menu-item" href="/resume/">Resume</a></li><li><a class="menu-item" href="/about/">About</a></li></ul></header><main id="swup"><h1 class="page-title">[UKR] Рецепт навчання нейрнонних мереж</h1><p><em>Переклад статті <a href="https://karpathy.github.io/2019/04/25/recipe/" target="_blank" rel="noopener" >A Recipe for Training Neural Networks</a> від імені автора (Andrej Karpathy). З деякими додатковими посиланнями.</em></p>
<p><div class="lazyload" style="padding-bottom: 85.60606060606061%" data-bg="url(/assets/optimized-img/stonks-neural-networks.jpg)" title="Кожен раз коли хтось використовує нейронки аби вирішити якусь проблему"><a data-no-swup target="_blank" class="download-link" title="Open full image" href="/assets/img/stonks-neural-networks.jpg"></a></div></p>
<p>Кілька тижнів тому я <a href="https://twitter.com/karpathy/status/1013244313327681536?lang=en" target="_blank" rel="noopener" >опублікував</a> твіт на тему «найчастіші помилки з нейронками», перелічивши декілька загальних помилок які належать до навчання нейронних мереж. Твіт отримав дещо більше взаємодій ніж я очікував (включаючи цілий <a href="https://www.bigmarker.com/missinglink-ai/PyTorch-Code-to-Unpack-Andrej-Karpathy-s-6-Most-Common-NN-Mistakes" target="_blank" rel="noopener" >вебінар</a> :)). Справді, багато людей помітили великий розрив між тим «ось як працює згортковий шар» та «наша згорткова мережа досягає результатів витвору мистецтва».</p>
<p>Тож я подумав, що буде весело змести пил зі свого блогу аби розкрити свій твіт в об&#39;ємнішому форматі, якого і заслуговує ця тема. Однак замість того щоб поглиблюватись в перелік ще більшої кількості частих помилок або їх конкретизацію, я хотів би копнути глибше та поговорити про те як оминути ці помилки цілком (або ж виправити їх дуже швидко). Фокус в тому, щоб слідувати певному процесу, який, наскільки я можу сказати, не часто документується. Давайте почнемо з двох важливих спостережень, які спонукали до цього.</p>
<h3 id="1-нейронні-мережі-це-дірява-абстракція">1) Нейронні мережі це дірява абстракція</h3>
<p>Це ніби просто почати навчати нейронні мережі. Кілька бібліотек та фреймворків пишаються показом магічних 30-рядкових шматків коду які вирішують проблеми з вашими даними, даючи (хибні) враження, що це все працює з коробки. Звично бачити подібні речі:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>your_data = <span class="hljs-comment"># підставте свій датасет тут</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = SuperCrossValidator(SuperDuper.fit, your_data, ResNet50, SGDOptimizer)
<span class="hljs-comment"># підкоріть світ тут</span></code></pre>
<p>Ці бібліотеки та приклади активують частину нашого мозку яка звична зі стандартними програмами - місце де чисті API та абстракції часто досяжні. Для прикладу бібліотека <a href="https://2.python-requests.org/en/master/" target="_blank" rel="noopener" >requests</a>:</p>
<pre><code data-lang="python" class="hljs"><span class="hljs-meta">&gt;&gt;&gt; </span>r = requests.get(<span class="hljs-string">'https://api.github.com/user'</span>, auth=(<span class="hljs-string">'user'</span>, <span class="hljs-string">'pass'</span>))
<span class="hljs-meta">&gt;&gt;&gt; </span>r.status_code
<span class="hljs-number">200</span></code></pre>
<p>Круто! Сміливий розробник переклав на себе тягар розуміння рядків запитів, URL-адрес, GET/POST запитів, HTTP з&#39;єднань, тощо, і багато в чому приховав складність за кількома рядками коду. Це те з чим ми знайомі та очікуємо. На жаль, нейронні мережі не схожі на це. Вони не &quot;готова&quot; технологія, коли ви трохи відхиляєтесь від навчання класифікатора <a href="https://en.wikipedia.org/wiki/ImageNet" target="_blank" rel="noopener" >ImageNet</a>. Я намагався вказати на це у своїй публікації <a href="https://medium.com/@karpathy/yes-you-should-understand-backprop-e2f06eab496b" target="_blank" rel="noopener" >&quot;Так ви маєте розуміти метод зворотного поширення помилки&quot; (“Yes you should understand backprop”)</a>, вибравши метод зворотного поширення помилки та назвавши його &quot;дірявою абстракцією&quot;, але ситуація, на жаль, набагато важча. <a href="https://uk.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%B7%D0%B2%D0%BE%D1%80%D0%BE%D1%82%D0%BD%D0%BE%D0%B3%D0%BE_%D0%BF%D0%BE%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%BD%D1%8F_%D0%BF%D0%BE%D0%BC%D0%B8%D0%BB%D0%BA%D0%B8" target="_blank" rel="noopener" >&quot;Зворотне поширення помилки&quot;</a> + <a href="https://uk.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D1%81%D1%82%D0%BE%D1%85%D0%B0%D1%81%D1%82%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE_%D0%B3%D1%80%D0%B0%D0%B4%D1%96%D1%94%D0%BD%D1%82%D0%B0" target="_blank" rel="noopener" >&quot;Стохастичний градієнтний спуск&quot;</a> не робить вашу нейронну мережу магічно працюючою. Пакетна нормалізація не змушує її магічно <a href="https://en.wikipedia.org/wiki/Convergence_(logic)" target="_blank" rel="noopener" >сходитись</a> швидше. <a href="https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D0%B5%D0%BD%D1%82%D0%BD%D0%B0_%D0%BD%D0%B5%D0%B9%D1%80%D0%BE%D0%BD%D0%BD%D0%B0_%D0%BC%D0%B5%D1%80%D0%B5%D0%B6%D0%B0" target="_blank" rel="noopener" >Рекурентні нейронні мережі</a> не дозволяють магічно &quot;вставити&quot; текст. І лише тому, що ви можете сформулювати вашу проблему в формі <a href="https://uk.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B2%D1%87%D0%B0%D0%BD%D0%BD%D1%8F_%D0%B7_%D0%BF%D1%96%D0%B4%D0%BA%D1%80%D1%96%D0%BF%D0%BB%D0%B5%D0%BD%D0%BD%D1%8F%D0%BC" target="_blank" rel="noopener" >&quot;навчання з підкріпленням&quot;</a> не означає, що ви повинні це робити. Якщо ви наполягаєте на використанні технології, не знаючи як вона працює, ви, ймовірно, зазнаєте невдачі. Що підводить мене до...</p>
<h3 id="2-навчання-нейронних-мереж-ламається-мовчки">2) Навчання нейронних мереж ламається мовчки</h3>
<p>Коли ви неправильно написали або налаштували код ви часто отримуєте певне виключення. Ви передали ціле число там де очікується рядок. Функція очікує лише 3 аргументи. Цей імпорт невдалий. Той ключ не існує. Кількість елементів у двох списках не рівна. В додачу, часто можливо створити юніт-тести для певного функціоналу.</p>
<p>Це лише початок, коли справа стосується тренування нейронних мереж. Все може бути синтаксично вірно, але вкупі не впорядковано належним чином, і про це справді важко сказати (компілятору або інтерпретатору). &quot;Можлива поверхня помилок&quot; велика, логічна (на відміну від синтаксичної) та дуже складна для юніт-тестування. Наприклад, ви забули перевернути шар позначень коли перевертали зображення під час <a href="https://en.wikipedia.org/wiki/Data_augmentation" target="_blank" rel="noopener" >аугментації даних</a>. Ваша мережа все ще (що шокує) може працювати досить добре, тому що ваша мережа може внутрішньо навчитися виявляти перевернуті зображення, а потім перевертати свої прогнози. Або, можливо, ваша авторегресивна модель випадково приймає те, що вона намагається передбачити, як інформацію на вході через непомітну помилку. Або ви намагалися обрізати свої градієнти, але замість цього обрізали втрату, що спричинило ігнорування <a href="https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BA%D0%B8%D0%B4_(%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%81%D1%82%D0%B8%D0%BA%D0%B0)" target="_blank" rel="noopener" >викидів</a>, під час навчання. Або ви ініціалізували ваші ваги з попереднього навчання, але не використали вихідне середнє. Або ви просто зіпсували налаштування <a href="https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%B8%D0%B7%D0%B0%D1%86%D1%96%D1%8F_(%D0%BC%D0%B0%D1%82%D0%B5%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0)" target="_blank" rel="noopener" >регуляризації</a>, швидкості навчання, розміру моделі, і т.д. Тому ваша неправильно налаштована нейронна мережа викине виключення, лише якщо вам пощастить; Здебільшого вона тренується, але мовчки працює трохи гірше.</p>
<p>Як результат, (і це дуууже складно переоцінити) <strong>&quot;швидкий і лютий&quot; підхід до навчання нейронних мереж не працює</strong> і призводить лише до страждань. Зараз страждання є цілком природною частиною того, щоб нейронна мережа працювала добре, але їх можна пом&#39;якшити, якщо бути вдумливими, захищеними, параноїдальними та одержимими візуалізацією практично всього. Якість, яка на моєму досвіді найбільше корелює з успіхом у глибокому навчанні, - це терпіння та увага до деталей.</p>
<h2 id="рецепт">Рецепт</h2>
<p>На тлі вищезгаданих двох фактів, я розробив для себе конкретний процес, якого я дотримуюсь, застосовуючи нейронну мережу до нової проблеми, і який я спробую описати. Ви побачите, що ці два принципи сприймаються дуже серйозно. Зокрема, проходить побудова від простого до складного та на кожному кроці ми робимо певні гіпотези про те, що станеться, а потім або перевіряємо їх експериментом, або досліджуємо, поки не знайдемо якоїсь проблеми. Те, чого ми намагаємось всіма силами запобігти - це введення великої кількості &quot;неперевіреної&quot; складності одразу, що обов&#39;язково приведе до помилок або неправильної конфігурації, пошуки яких триватимуть вічно. Якби процес написання коду нейронної мережі був би подібним до навчання нейронки (тут написання коду нейронки вжито як пряма аналогія до навчання нейронки, але вже в вашому лиці), то ви хотіли б використовувати дуже малу швидкість навчання і вгадувати, а потім оцінювати повний набір тестів після кожної ітерації.</p>
<h3 id="1-станьте-єдиними-з-даними">1. Станьте єдиними з даними</h3>
<p>Перший крок до навчання нейронних мереж - це взагалі не торкатися коду нейронної мережі, а натомість почати з ретельної перевірки ваших даних. Цей крок критичний. Я люблю витрачати багато часу (вимірюється в годинах), перевіряючи тисячі прикладів, розуміючи їх розподіл та шукаючи закономірності. На щастя, ваш мозок добре з цим справляється. Одного разу я виявив, що дані містять приклади які повторюються. Іншого разу я виявив пошкоджені зображення / розмітку. Я шукаю дисбаланс даних та зміщення. Зазвичай я також звертаю увагу на свій власний процес класифікації даних, який натякає на види архітектур які ми з часом вивчимо. Як приклад - чи достатньо локальних особливостей, чи нам потрібен глобальний контекст? Скільки існує варіацій та яку форму вони приймають? Яка варіація хибна і може бути попередньо оброблена? Чи має значення просторове положення чи ми хочемо його усереднити (з допомогою операції average pool)? Наскільки важливі деталі і як далеко ми можемо дозволити собі зменшити розмір зображень? Наскільки шумна розмітка?</p>
<p>Крім того, оскільки нейронна мережа є фактично стисненою / скомпільованою версією вашого набору даних, ви зможете переглянути свої (помилкові) прогнози у вашій мережі та зрозуміти, звідки вони можуть надходити. І якщо ваша мережа дає вам прогноз який не відповідає тому, що ви бачили в даних, то щось пішло не так.</p>
<p>Отримавши розуміння якісної характеристики, також хорошою ідеєю є написання якогось простого коду для здійснення пошуку / фільтрування / сортування за будь-якою можливою характеристикою (наприклад, за типом мітки, розміром анотацій, кількістю анотацій тощо) та візуалізувати їх розподіл і викиди по будь-якій осі. Викиди майже завжди викривають якісь баги в даних або в їх підготовці.</p>
<h3 id="2-налаштуйте-наскрізний-скелет-навчання--оцінки--отримайте-простий-базис-базову-модель">2. Налаштуйте наскрізний скелет навчання / оцінки + отримайте простий базис (базову модель)</h3>
<p>Тепер, коли ми зрозуміли наші дані, чи можемо ми дістатись до нашої надзвичайної великомасштабної ASPP FPN ResNet та розпочати навчання чудових моделей? Точно ні. Це шлях до страждань. Наш наступний крок - створити повний скелет <em>навчання + оцінка</em> та завоювати довіру до його правильності шляхом серії експериментів. На цьому етапі найкраще вибрати якусь просту модель, яку не можна було якось зіпсувати - наприклад лінійний класифікатор або дуже крихітну згорткову мережу. Ми хочемо навчати мережу, візуалізувати втрати, будь-які інші показники (наприклад, точність), моделювати прогнози та проводити низку експериментів по <a href="https://en.wikipedia.org/wiki/Ablation_(artificial_intelligence)" target="_blank" rel="noopener" >відключенню частин мережі</a> (при цьому висувати гіпотези як це вплине на результати) на всьому шляху.</p>
<p>Поради та підказки на цьому етапі:</p>
<ul>
<li><p><strong>зафіксуйте <a href="https://uk.wikipedia.org/wiki/%D0%92%D0%B8%D0%BF%D0%B0%D0%B4%D0%BA%D0%BE%D0%B2%D0%B5_%D0%BF%D0%BE%D1%87%D0%B0%D1%82%D0%BA%D0%BE%D0%B2%D0%B5_%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%BD%D1%8F" target="_blank" rel="noopener" >випадкове початкове значення</a></strong>. Завжди використовуйте фіксоване випадкове початкове значення аби гарантувати аналогічний результат при повторному запуску. Це усуває фактор варіативності та підтримає вашу впевненість.</p>
</li>
<li><p><strong>спрощуйте</strong>. Не забудьте відключити будь-яку непотрібну химерність. Як приклад, на цьому етапі вимкніть будь-яку аугментацію даних. Аугментація даних - це стратегія регуляризації, яку ми можемо включити пізніше, але наразі це просто ще одна можливість внести якусь тупу помилку.</p>
</li>
<li><p><strong>додайте значущі цифри до вашої оцінки</strong>. Під час побудови графіку тестових втрат проведіть оцінку по всьому (великому) набору тестів. Не просто складайте тестові втрати за партіями, а потім покладайтесь на їх згладжування в Tensorboard. Ми переслідуємо правильність і серйозно налаштовані приділити час для збереження впевненості.</p>
</li>
<li><p><strong>перевіряйте втрати на початку</strong>. Переконайтеся, що показник втрати починається з правильного значення. Наприклад, якщо ви правильно ініціалізуєте свій кінцевий шар, то у вас повинно вийти <code>-log(1/n_classes)</code> для функції softmax при ініціалізації. Ті самі значення за замовчуванням можна отримати для регресії L2, втрат Губера тощо.</p>
</li>
<li><p><strong>вірно ініціалізуйте</strong>. Правильно ініціалізуйте ваги кінцевого шару. Наприклад, якщо ви регресуєте деякі значення, які мають середнє значення 50, тоді ініціалізуйте остаточне зміщення до 50. Якщо у вас незбалансований набір даних зі співвідношенням 1:10, встановіть зміщення на своїх <a href="https://en.wikipedia.org/wiki/Logit" target="_blank" rel="noopener" >логітах</a> так, щоб ваша мережа давала передбачення 0.1 при ініціалізації. Правильне їх встановлення пришвидшить збіжність та усуне криві втрат у вигляді &quot;хокейної ключки&quot;, де у перші кілька ітерацій ваша мережа в основному лише вивчає зміщення.</p>
</li>
<li><p><strong>людський базис</strong>. Відстежуйте й інші показники, крім втрат, які можна інтерпретувати та перевірити людиною (наприклад, точність). По можливості оцінюйте власну (людську) точність і порівнюйте з нею. Крім того, двічі анотуйте тестові дані та для кожного прикладу розгляньте одну анотацію як передбачення, а другу як <a href="https://uk.wikipedia.org/wiki/Ground_truth" target="_blank" rel="noopener" >основну правду</a>.</p>
</li>
<li><p><strong>незалежний від вхідних значень базис</strong>. Тренуйте незалежний від вхідних значень базис (наприклад, найпростішим є встановлення всіх вхідних значень на нуль). Це має працювати гірше, ніж тоді, коли ви фактично підключаєте свої дані, не обнуляючи їх. Дійсно так? Дійсно ваша модель взагалі вчиться витягувати будь-яку інформацію із вхідних даних?</p>
</li>
<li><p><strong>перенавчайте на одній партії</strong>. Робіть <a href="https://uk.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%BD%D0%B0%D0%B2%D1%87%D0%B0%D0%BD%D0%BD%D1%8F" target="_blank" rel="noopener" >перенавчання</a> на одній партії лише кількома прикладами (наприклад, лише двома). Для цього ми збільшуємо обсяг нашої моделі (наприклад, додаємо шари або фільтри) і перевіряємо, що ми можемо досягти найнижчих досяжних втрат (наприклад, нульових). Мені також подобається візуалізувати на одному і тому ж графіку як розмічену інформацію, так і прогноз, аби переконатися, що вони ідеально вирівнюються, як тільки ми досягнемо мінімальних втрат. Якщо цього не сталося, десь є помилка, і ми не можемо перейти до наступного етапу.</p>
</li>
<li><p><strong>перевіряйте зменшення втрат на тренувальній вибірці</strong>. Гадаю, ваш набір даних буде не дуже об&#39;ємним, оскільки ви працюєте з іграшковою моделлю. Спробуйте трохи збільшити його обсяг. Значення втрат на тренувальній вибірці знизилися як слід?</p>
</li>
<li><p><strong>візуалізуйте безпосередньо перед входом нейронки</strong>. Однозначно правильне місце для візуалізації ваших даних знаходиться безпосередньо перед вашим <code>y_hat = model(x)</code> (або <code>sess.run</code> у Tensorflow). Тобто - ви маєте візуалізувати саме те, що потрапляє у вашу мережу, декодуючи цей необроблений тензор даних та міток у вигляді якоїсь візуалізації. Це єдине “джерело істини”. Я не можу порахувати, скільки разів це мене рятувало та виявляло проблеми з попередньою обробкою та аугментацією даних.</p>
</li>
<li><p><strong>візуалізуйте динаміку прогнозів</strong>. Мені подобається візуалізувати прогнози моделей на фіксованій тестовій партії під час навчання. &quot;Динаміка&quot; руху цих прогнозів дасть вам неймовірно хорошу інтуїцію щодо того, як прогресує тренування. Здебільшого можна відчути, як мережа «бореться» за розміщення ваших даних, якщо вона якось вагається, показуючи нестабільність. Дуже низька або дуже висока швидкість навчання також легко помітні за величиною тремтіння.</p>
</li>
<li><p><strong>використовуйте метод зворотного розповсюдження помилки для відстежування залежностей</strong>. Ваш код для глибокого навчання часто міститиме складні, векторизовані та трансляційні операції. Досить поширена помилка, з якою я стикався кілька разів, полягає в тому, що люди досягають цього неправильно (наприклад, вони використовують <code>view</code>, а не <code>transpose/permute</code>) і ненавмисно змішують інформацію у вимірі розміру пакета. Пригнічує той факт, що ваша мережа, як правило, все одно добре навчатиметься, тому що вона навчиться ігнорувати дані з інших прикладів. Одним зі способів налагодження цієї (та інших пов&#39;язаних з цим проблем) є встановлення функції втрати як чогось тривіального, такого як сума всіх виходів прикладу <em>i</em>, запуск зворотного проходу аж до вхідного сигналу та забезпечення отримання ненульового градієнта лише на <em>i</em>-му вході. Ту саму стратегію можна використовувати аби переконатись, що ваша авторегресивна модель у момент часу <em>t</em> залежить лише від <em>1..t-1</em>. Більш загально, градієнти дають вам інформацію про те, що і від чого залежить у вашій мережі, це може бути корисно для налагодження.</p>
</li>
<li><p><strong>узагальнюйте окремий випадок</strong>. Це більше схоже на пораду узагальнювати код, але я часто бачив, як люди роблять помилки, коли відкушують більше, ніж можуть жувати, пишучи відносно загальну функціональність з нуля. Мені подобається писати дуже конкретну функцію для того, що я роблю зараз, змусити це працювати, а потім узагальнити її пізніше, переконавшись, що я отримаю той самий результат. Часто це стосується векторизації коду, де я майже завжди виписую повністю циклічну версію, а вже потім перетворюю її на векторизований код по одному циклу.</p>
</li>
</ul>
<h3 id="3-перенавчайте">3. Перенавчайте</h3>
<p>На цьому етапі ми повинні добре розуміти набір даних, і ми маємо повний конвеєр навчання + оцінки. Для будь-якої даної моделі ми можемо (відтворювано) обчислити метрику, якій ми довіряємо. Ми також озброєні результатами нашого незалежного від вхідних даних базису, результатами кількох простих базисів (нам краще перемогти саме їх), і ми маємо приблизне відчуття продуктивності людини (ми сподіваємось досягти цього рівня). Поточний етап направлений на ітерації в напрямку хорошої моделі.</p>
<p>Підхід, який я люблю застосовувати до пошуку хорошої моделі, складається з двох етапів: спочатку отримати модель, достатньо велику, щоб вона могла перенавчитись (тобто зосередити увагу на значенні втрат тренувальної вибірки), а потім регулювати її належним чином (погіршити деякі значення втрат навчальної вибірки, щоб покращити значення втрат під час перевірки). Причиною, чому мені подобаються ці два етапи, є те, що якщо ми не можемо досягти низького рівня помилок з будь-якою моделлю взагалі, це може знову вказувати на якісь проблеми, помилки або неправильну конфігурацію.</p>
<p>Кілька порад та підказок на цьому етапі:</p>
<ul>
<li><p><strong>підбір моделі</strong>. Щоб досягти хороших значень втрат навчальної вибірки, ви маєте вибрати відповідну архітектуру даних. Коли справа доходить до її вибору, моя перша порада: <strong>Не будьте героєм</strong>. Я бачив багато людей, які прагнуть зійти з розуму в креативності підбору лего-блоків з набору інструментів нейронних мереж у процесі створення різних екзотичних архітектур, які мають сенс лише для них. На перших етапах проекту всіма силами чиніть опір цій спокусі. Я завжди раджу людям просто знайти найбільш схожу наукову роботу і скопіювати її найпростішу архітектуру, яка забезпечує хороші показники. Наприклад якщо ви класифікуєте зображення, не будьте героєм, а просто скопіюйте ResNet-50 для першого запуску. Ви зможете робити щось більш специфічне пізніше і перемогти цей пункт.</p>
</li>
<li><p><strong>Adam (метод адаптивної оцінки моментів) безпечний</strong>. На ранніх стадіях встановлення базису мені подобається використовувати Adam зі швидкістю навчання <code>3e-4</code>. З мого досвіду, Adam набагато лояльніший до гіперпараметрів, включаючи погану швидкість навчання. Для згорткових нейронок добре налаштований метод стохастичного градієнта (SGD) майже завжди трохи перевершує Adam, але область оптимальної швидкості навчання набагато вужча і залежить від задачі. (Примітка. Якщо ви використовуєте рекурентні нейронки та пов’язані з ними моделі обробки послідовностей, то частіше використовують Adam. Знову ж таки, на початковому етапі свого проекту не будьте героєм і дотримуйтесь усіх найпопулярніших статей.)</p>
</li>
<li><p><strong>ускладнюйте лише по одному</strong>. Якщо у вас є кілька сигналів для підключення до вашого класифікатора, я б порадив вам приєднати їх один за одним і кожного разу переконуватись, що ви отримуєте підвищення продуктивності, яке ви очікували. Не кидайте відро помий на свою модель на самому початку. Є й інші способи нарощення складності - наприклад, ви можете спробувати підключити спочатку менші зображення, а пізніше збільшити їх тощо.</p>
</li>
<li><p><strong>не довіряйте коефіцієнту зменшення швидкості навчання за замовчуванням</strong>. Якщо ви переробляєте код з якоїсь іншої задачі, завжди будьте дуже обережні зі зниженням швидкості навчання. Ви не тільки хотіли б використовувати різні графіки зниження швидкості навчання для різних проблем, але - що ще гірше - у типовій реалізації зниження базуватиметься на поточному номері епохи, який може широко варіюватися просто залежно від розміру вашого набору даних. Наприклад, ImageNet сповільниться у 10 разів на 30-й епосі. Якщо ви не тренуєтеся з ImageNet (мається на увазі розмір датасету), ви, майже напевно, цього не хочете. Якщо ви не будете обережні, ваш код може потайки зводити вашу швидкість навчання до нуля занадто рано, не дозволяючи вашій моделі сходитися. У своїй власній роботі я завжди повністю вимикаю рівень зниження швидкості навчання (я використовую постійну швидкість навчання) і налаштовую це в самому кінці.</p>
</li>
</ul>
<h3 id="4-регуляризуйте">4. Регуляризуйте</h3>
<p>В ідеалі, ми зараз знаходимося в тому місці, де маємо велику модель, яка підходить як мінімум для навчального набору. Зараз настав час його регуляризувати та отримати певну точність перевірки, відмовившись від частини точності на навчальній вибірці. Деякі поради та підказки:</p>
<ul>
<li><p><strong>отримайте більше даних</strong>. По-перше, безумовно найкращим способом регуляризування моделі в будь-якому практичному середовищі є додавання більшої кількості реальних навчальних даних. Дуже поширеною помилкою є проведення багатьох інженерних циклів, намагаючись вичавити сік з невеликого набору даних, коли замість цього можна було збирати більше даних. Наскільки мені відомо, додавання додаткових даних є чи не єдиним гарантованим способом монотонно покращувати продуктивність добре налаштованої нейронної мережі майже необмежено довго. Інші - це ансамблі нейронок (якщо ви можете їх собі дозволити), але це обмежується ~ 5-ма моделями.</p>
</li>
<li><p><strong>аугментація даних</strong>. Наступним найкращим способом після реальних даних є напівфальшиві дані - спробуйте більш агресивну аугментацію даних.</p>
</li>
<li><p><strong>креативна аугментація</strong>. Якщо напівфальшиві дані не допомогли, фейкові дані також можуть щось зробити. Люди знаходять творчі способи розширення наборів даних; Наприклад, <a href="https://openai.com/blog/learning-dexterity/" target="_blank" rel="noopener" >рандомізація доменів</a>, використання <a href="https://vladlen.info/publications/playing-data-ground-truth-computer-games/" target="_blank" rel="noopener" >моделювання</a>, розумні <a href="https://arxiv.org/abs/1708.01642" target="_blank" rel="noopener" >гібриди</a>, такі як вставка (потенційно змодельована) даних у сцени або навіть <a href="https://uk.wikipedia.org/wiki/%D0%93%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%B0_%D0%B7%D0%BC%D0%B0%D0%B3%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0_%D0%BC%D0%B5%D1%80%D0%B5%D0%B6%D0%B0" target="_blank" rel="noopener" >GAN</a>.</p>
</li>
<li><p><strong>попередньо натреновуйте</strong>. Рідко коли-небудь шкодить використовувати попередньо навчену мережу, якщо вам дозволяє ситуація, навіть якщо у вас достатньо даних.</p>
</li>
<li><p><strong>дотримуйтеся контрольованого навчання (навчання з учителем)</strong>. Не переоцінюйте попереднє навчання без нагляду (без учителя). На відміну від того, що розповідається в тому дописі в блозі від 2008 року [не можу зрозуміти про який допис тут йде мова], наскільки мені відомо, немає версій які показують хороші результати на сучасних завданнях комп&#39;ютерного зору (хоча <a href="https://uk.wikipedia.org/wiki/%D0%9E%D0%B1%D1%80%D0%BE%D0%B1%D0%BA%D0%B0_%D0%BF%D1%80%D0%B8%D1%80%D0%BE%D0%B4%D0%BD%D0%BE%D1%97_%D0%BC%D0%BE%D0%B2%D0%B8" target="_blank" rel="noopener" >NLP</a>, здається, цілком добре справляється разом з <a href="https://uk.wikipedia.org/wiki/BERT_(%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C_%D0%BC%D0%BE%D0%B2%D0%B8)" target="_blank" rel="noopener" >BERT</a> та компанією на сьогодні, цілком імовірно завдяки навмисному характеру тексту та вищому співвідношенню <em>сигнал / шум</em>).</p>
</li>
<li><p><strong>зменшуйте вхідну розмірність</strong>. Видаліть приклади, які можуть містити помилковий сигнал. Будь-який доданий помилковий ввід - це лише чергова можливість перенавчити (коли ваша нейронка зазубрить приклад), якщо ваш набір даних невеликий. Подібним чином, якщо деталі низького рівня не мають великого значення, спробуйте передавати зображення меншого розміру.</p>
</li>
<li><p><strong>зменшуйте розмір моделі</strong>. У багатьох випадках ви можете використовувати обмеження інформативності ділянки в мережі, щоб зменшити її розмір. Як приклад, раніше було модно використовувати шари з повним з&#39;єднанням поверх основи з ImageNet, але відтоді вони були замінені простим середнім об’єднанням (average pooling), усуваючи тонну параметрів у процесі.</p>
</li>
<li><p><strong>зменшуйте розмір партії</strong>. Через нормалізацію всередині норми партії менші розміри партії дещо відповідають сильнішій регуляризації регуляризації. Це пов’язано з тим, що емпіричне <em>середнє/стандартний розподіл</em> для партії є більш приблизними версіями <em>повного середнього/стандартний розподіл</em>, тому зміна масштабу і зміщення &quot;гойдають&quot; вашу партію більше.</p>
</li>
<li><p><strong>відсіюйте</strong>. Додайте відсіювання. Використовуйте dropout2d (просторове відсіювання) для згорткових мереж. Використовуйте це помірковано/обережно, оскільки, здається, відсіювання не добре працює при нормалізації партії.</p>
</li>
<li><p><strong>зменшення ваги</strong>. Збільште коефіцієнт зменшення ваги (ефект забування).</p>
</li>
<li><p><strong>рання зупинка</strong>. Зупиняйте тренування на основі виміряних валідаційних втрат, щоб зловити свою модель саме тоді, коли вона збирається перенавчитися (зазубрити приклади, а не вивчити загальні особливості).</p>
</li>
<li><p><strong>спробуйте більшу модель</strong>. Я згадую це останнім і лише після ранньої зупинки, адже раніше я кілька разів виявляв, що більші моделі з часом, звичайно, перенавчаються набагато сильніше, але їхня “зупинена” ефективність часто може бути набагато кращою, ніж у моделей меншого розміру.</p>
</li>
</ul>
<p>Нарешті, щоб отримати додаткову впевненість у тому, що ваша мережа є розумним класифікатором, я люблю візуалізувати ваги першого рівня мережі та гарантувати, що ви отримуєте гарні межі, які мають сенс. Якщо ваші фільтри першого шару схожі на шум, тоді щось може бути не так. Подібним чином активації всередині мережі іноді можуть показувати дивні артефакти та натякати на проблеми.</p>
<h3 id="5-тюнінгуйте">5. Тюнінгуйте</h3>
<p>Тепер ви повинні бути &quot;зв&#39;язані&quot; з вашим набором даних, вивчаючи широкий простір моделей для архітектур, які досягають низьких втрат під час перевірки. Кілька порад та підказок для цього кроку:</p>
<ul>
<li><p><strong>випадковий пошук по сітці</strong>. Для одночасного налаштування декількох гіперпараметрів може здатися спокусливим використовувати пошук по сітці, щоб забезпечити охоплення всіх налаштувань, але майте на увазі, що найкраще замість цього використовувати випадковий пошук. Інтуїтивно це пов’язано з тим, що нейронні мережі часто набагато чутливіші до одних параметрів, ніж до інших. Загалом, якщо параметр <em>a</em> важливий, але зміна <em>b</em> не має ефекту, ви підбираєте значення <em>a</em> більш продумано, ніж у кількох фіксованих точках декілька разів.</p>
</li>
<li><p><strong>оптимізація гіперпараметрів</strong>. Навколо є велика кількість вигадливих наборів інструментів для оптимізації байєсових гіперпараметрів, і кілька моїх друзів також повідомили про успіх з ними, але мій особистий досвід полягає в тому, що сучасний підхід до вивчення прекрасного та широкого простору моделей та гіперпараметрів полягає у використанні інтерна :). Жартую.</p>
</li>
</ul>
<h3 id="6-витисніть-всі-соки">6. Витисніть всі соки</h3>
<p>Знайшовши найкращі типи архітектур та гіперпараметри, ви все ще можете скористатися ще кількома хитрощами, щоб вичавити останні каплі соку з системи:</p>
<ul>
<li><p><strong>ансамблі</strong>. Ансамблі моделей - це майже гарантований спосіб отримати 2% точності на чому-небудь. Якщо ви не можете дозволити собі обчислення під час тестування, погляньте на перегонку свого ансамблю в мережу, використовуючи <a href="https://arxiv.org/abs/1503.02531" target="_blank" rel="noopener" >темні знання</a>.</p>
</li>
<li><p><strong>залиште її тренуватись</strong>. Я часто бачив людей, які спокушаються припинити навчання моделей, коли втрата валідації, здається, вирівнюється. З мого досвіду, мережі продовжують тренуватися неінтуїтивно довго. Одного разу я випадково покинув тренування моделі під час зимових канікул, і коли повернувся в січні, я побачив SOTA (state of the art - “сучасний рівень”).</p>
</li>
</ul>
<h2 id="висновок">Висновок</h2>
<p>Як тільки ви потрапите сюди, у вас будуть усі складові успіху: Ви глибоко розумієте технологію, набір даних та проблему, ви створили всю інфраструктуру навчання / оцінки та досягли високої впевненості у її точності, Ви досліджували дедалі складніші моделі, отримуючи поліпшення продуктивності способами, які ви передбачали на кожному кроці. Тепер ви готові прочитати багато робіт, спробувати велику кількість експериментів і отримати свої результати SOTA. Удачі!</p>
<p class="thank-you-for-attention 😉">Thank you for attention!</p></main></div><footer>© Mikola Parfenyuck<div class="social-links"><a class="icon icon-twitter" rel="noopener" target="_blank" aria-label="My twitter" title="My twitter" href="https://twitter.com/i_rapkin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 72 72"><path d="M67.812 16.141a26.246 26.246 0 0 1-7.519 2.06 13.134 13.134 0 0 0 5.756-7.244 26.127 26.127 0 0 1-8.313 3.176A13.075 13.075 0 0 0 48.182 10c-7.229 0-13.092 5.861-13.092 13.093 0 1.026.118 2.021.338 2.981-10.885-.548-20.528-5.757-26.987-13.679a13.048 13.048 0 0 0-1.771 6.581c0 4.542 2.312 8.551 5.824 10.898a13.048 13.048 0 0 1-5.93-1.638c-.002.055-.002.11-.002.162 0 6.345 4.513 11.638 10.504 12.84a13.177 13.177 0 0 1-3.449.457c-.846 0-1.667-.078-2.465-.231 1.667 5.2 6.499 8.986 12.23 9.09a26.276 26.276 0 0 1-16.26 5.606A26.21 26.21 0 0 1 4 55.976a37.036 37.036 0 0 0 20.067 5.882c24.083 0 37.251-19.949 37.251-37.249 0-.566-.014-1.134-.039-1.694a26.597 26.597 0 0 0 6.533-6.774z"></path></svg>
</a><a class="icon icon-github" rel="noopener" target="_blank" aria-label="My github" title="My github" href="https://github.com/rapkin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path></svg>
</a></div></footer><script src="/assets/js/bundle.js"></script></body></html>